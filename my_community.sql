/*
 Navicat Premium Data Transfer

 Source Server         : 本地8.0 - 3307
 Source Server Type    : MySQL
 Source Server Version : 80026
 Source Host           : localhost:3307
 Source Schema         : my_community

 Target Server Type    : MySQL
 Target Server Version : 80026
 File Encoding         : 65001

 Date: 27/08/2023 04:12:16
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `parent_id` bigint NOT NULL COMMENT '文章ID',
  `type` int NOT NULL COMMENT '1：问题的评论  2：回复的评论',
  `content` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论内容',
  `commentator` bigint NOT NULL COMMENT '评论人',
  `gmt_create` bigint NOT NULL COMMENT '评论时间',
  `gmt_modified` bigint NOT NULL COMMENT '修改时间',
  `like_count` bigint NULL DEFAULT 0 COMMENT '点赞数',
  `comment_count` bigint NULL DEFAULT 0 COMMENT '评论数',
  `is_deleted` tinyint NOT NULL DEFAULT 0 COMMENT '删除标记 0 正常 1删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 1, 1, '6', 1, 1673091700143, 1673091700143, 0, 3, 0);
INSERT INTO `comment` VALUES (2, 1, 2, '66', 1, 1673091703805, 1673091703805, 0, 0, 0);
INSERT INTO `comment` VALUES (3, 1, 2, '666', 2, 1675483180726, 1675483180726, 0, 0, 0);
INSERT INTO `comment` VALUES (4, 1, 1, '666', 2, 1675483190417, 1675483190417, 0, 0, 0);
INSERT INTO `comment` VALUES (5, 2, 1, '6', 2, 1675593291356, 1675593291356, 0, 0, 0);
INSERT INTO `comment` VALUES (6, 2, 1, '66', 2, 1675593295122, 1675593295122, 0, 0, 0);
INSERT INTO `comment` VALUES (7, 2, 1, '666', 2, 1675593297993, 1675593297993, 0, 0, 0);
INSERT INTO `comment` VALUES (8, 1, 1, '666', 1626451643027533825, 1676630527657, 1676630527657, 0, 0, 0);
INSERT INTO `comment` VALUES (9, 13, 1, '情人节快乐~', 2, 1676703571720, 1676703571720, 0, 0, 0);
INSERT INTO `comment` VALUES (10, 1, 2, '1', 2, 1676802043463, 1676802043463, 0, 0, 0);
INSERT INTO `comment` VALUES (11, 1, 1, '2/19', 2, 1676802066438, 1676802066438, 0, 0, 0);
INSERT INTO `comment` VALUES (12, 1, 1, '2023/2/20', 1, 1676908213002, 1676908213002, 0, 0, 0);
INSERT INTO `comment` VALUES (13, 1, 1, '2023/2/21', 2, 1676969865301, 1676969865301, 0, 0, 0);
INSERT INTO `comment` VALUES (14, 1, 1, '2023/2/22', 1, 1677028786713, 1677028786713, 0, 0, 0);
INSERT INTO `comment` VALUES (15, 19, 1, '感谢阅览~', 1626609807895044097, 1677397301260, 1677397301260, 0, 0, 0);
INSERT INTO `comment` VALUES (17, 1, 1, '测试删除缓存评论', 1, 1677559238435, 1677559238435, 0, 0, 1);
INSERT INTO `comment` VALUES (18, 1, 1, '删除缓存评论测试', 1, 1677559753881, 1677559753881, 0, 0, 0);
INSERT INTO `comment` VALUES (19, 13, 1, '情人节快乐', 1, 1683453182053, 1683453182053, 0, 0, 0);
INSERT INTO `comment` VALUES (20, 19, 1, '6', 1626609807895044099, 1685147821374, 1685147821374, 0, 0, 0);
INSERT INTO `comment` VALUES (21, 19, 1, '评论', 1626609807895044099, 1685147827787, 1685147827787, 0, 0, 0);
INSERT INTO `comment` VALUES (22, 20, 1, '4二月份鬼画符鬼画符饭否非官方风光过后就会经过反复回放', 1626609807895044099, 1685152249615, 1685152249615, 0, 0, 0);
INSERT INTO `comment` VALUES (23, 20, 1, '4二月份鬼画符鬼画符饭否非官方风光过后就会经过反复回放', 1626609807895044099, 1685152260297, 1685152260297, 0, 0, 0);
INSERT INTO `comment` VALUES (24, 19, 1, '1', 1626609807895044099, 1685152439388, 1685152439388, 0, 0, 0);

-- ----------------------------
-- Table structure for notification
-- ----------------------------
DROP TABLE IF EXISTS `notification`;
CREATE TABLE `notification`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '通知消息id',
  `notifier_id` bigint NOT NULL COMMENT '通知者id',
  `notify_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '通知者姓名',
  `receiver_id` bigint NOT NULL COMMENT '接收者id',
  `target_id` bigint NOT NULL COMMENT '问题或评论id',
  `target_title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '问题标题',
  `type` int NOT NULL DEFAULT 1 COMMENT '通知的类型，1:问题，2:评论',
  `status` int NOT NULL DEFAULT 0 COMMENT '状态，0:未读，1:已读',
  `gmt_create` bigint NULL DEFAULT NULL COMMENT '通知时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of notification
-- ----------------------------
INSERT INTO `notification` VALUES (1, 2, 'axz', 1, 1, '测试', 2, 1, 1675483180755);
INSERT INTO `notification` VALUES (2, 2, 'axz', 1, 1, '测试', 1, 1, 1675483190425);
INSERT INTO `notification` VALUES (3, 1626451643027533825, '1@2.com', 1, 1, '测试', 1, 0, 1676630527694);
INSERT INTO `notification` VALUES (4, 2, 'axz', 1, 13, '情人节快乐~', 1, 0, 1676703571755);
INSERT INTO `notification` VALUES (5, 2, 'axz', 1, 1, '测试', 2, 0, 1676802043504);
INSERT INTO `notification` VALUES (6, 2, 'axz', 1, 1, '测试', 1, 0, 1676802066449);
INSERT INTO `notification` VALUES (7, 2, 'axz', 1, 1, '测试', 1, 0, 1676969865353);

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '问题ID',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标题',
  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '内容',
  `tags` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标签',
  `gmt_create` bigint NOT NULL COMMENT '发布时间',
  `gmt_modified` bigint NOT NULL COMMENT '更新时间',
  `comment_count` int NULL DEFAULT 0 COMMENT '评论数',
  `like_count` int NULL DEFAULT 0 COMMENT '喜欢数',
  `view_count` int NULL DEFAULT 0 COMMENT '浏览量',
  `creator` bigint NOT NULL COMMENT '提问作者',
  `top` int NULL DEFAULT 0 COMMENT '0不顶置 1顶置',
  `is_deleted` tinyint NOT NULL DEFAULT 0 COMMENT '删除标记 0正常 1删除',
  `status` tinyint UNSIGNED NULL DEFAULT 0 COMMENT '0正常1锁定',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (1, '测试', '还不错666', 'java,spring,linux,mysql,测试', 1673091643770, 1673091643770, 10, 0, 307, 1, 0, 0, 0);
INSERT INTO `question` VALUES (2, 'GITEE测试', '666\r\n```java\r\n@SpringBootApplication\r\npublic class CommunityApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(CommunityApplication.class, args);\r\n    }\r\n\r\n}\r\n```\r\n66\r\n# 1\r\n## 2\r\n### 3\r\n#### 4\r\n##### 5\r\n###### 6\r\n7', 'git,生活,测试', 1675483124842, 1675593316335, 3, 0, 14, 2, 0, 1, 0);
INSERT INTO `question` VALUES (3, '图片上传', '阿里云图片上传测试:watermelon:\r\n\r\n图片测试![](http://xiao-xiao.oss-cn-beijing.aliyuncs.com/1b188fe4-5310-4416-9ae3-78eb1019da83.jpg?Expires=1707186585&OSSAccessKeyId=LTAI5tLUsBPzeq8nF3a4HNWx&Signature=QL69onEkclVZc3OrTQqPBiFZ8lQ%3D)', '找bug,测试', 1675650745313, 1675650745313, 0, 0, 3, 2, 0, 1, 0);
INSERT INTO `question` VALUES (4, '关于MyBatis学习记录', '# MyBatis学习\r\n\r\n## 框架介绍\r\n\r\n- 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\r\n\r\n## MyBatis 快速入门\r\n\r\n### ORM 介绍\r\n\r\n- ORM(Object Relational Mapping)：**对象关系映射**\r\n\r\n- 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术\r\n\r\n  Object <-->ORM<-->DB     映射规则：数据表->类、表字段->类属性、表数据->对象\r\n\r\n### MyBatis 介绍\r\n\r\n- 原始  JDBC 的操作-查询\r\n\r\n```java\r\npublic class Test {\r\npublic static void main(String[] args) throws Exception{\r\n    Class.forName (\"com.mysq1.jdbc.Driver\");\r\n    String url = \"jdbc:mysql://localhost:3306/db1\";\r\n    String username = \"root\";\r\n    String password = \"root\";\r\n    Connection con = DriverManager.getConnection(url, username, password);\r\n    PreparedStatement pst = con.prepareStatement(\"SELECT * FROM student\");\r\n    ResultSet rs = pst. executeQuery();\r\n    while(rs.next()) {\r\n    Student stu = new Student( );\r\n    stu.setName(rs.getString(columnLabel: \"name\"));\r\n    stu.setAge(rs.getInt(columnLabel: \"age\"));\r\n    stu.setGender(rs.getString( columnLabel: \"gender\"));\r\n    System.out.println(stu);\r\n    }\r\n    rs.close();\r\n    pst.close( );\r\n    con.close( );\r\n    }\r\n}\r\n```\r\n\r\n- 原始  JDBC 的操作-查询\r\n\r\n```java\r\npublic class Test {\r\npublic static void main(String[] args) throws Exception{\r\n    Class.forName (\"com.mysq1.jdbc.Driver\");\r\n    String url = \"jdbc:mysql://localhost:3306/db1\";\r\n    String username = \"root\";\r\n    String password = \"root\";\r\n    Connection con = DriverManager.getConnection(url, username, password);\r\n  \r\n    PreparedStatement pst = con.prepareStatement(\"INSERT INTO student VALUES (?,?,?)\");\r\n    pst.setString(1, stu.getName());\r\n    pst.setInt(2, stu.getAge());\r\n    pst.setString(3, stu.getGender());\r\n    int result = pst.executeUpdate();\r\n    System.out.println(result);\r\n    pst.close( );\r\n    con.close( );\r\n    }\r\n}\r\n```\r\n\r\n- **原始  JDBC 的操作问题分析:**\r\n\r\n  1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\r\n\r\n  2.sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改  java 代码，造成代码不易维护。\r\n\r\n  3.查询操作时，需要手动将结果集中的数据封装到实体对象中。\r\n\r\n  4.增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。\r\n\r\n- **原始  JDBC 的操作问题解决方案:**\r\n\r\n  1.使用数据库连接池初始化连接资源。\r\n\r\n  2.将 sql 语句抽取到配置文件中。\r\n\r\n  3.使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射。\r\n\r\n  \r\n\r\n- MyBatis 是一个优秀的基于  Java 的持久层框架，它内部封装了  JDBC，使开发者只需要关注  SQL 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建执行者等复杂的操作。\r\n\r\n- MyBatis 通过  xml 或注解的方式将要执行的各种 Statement 配置起来，并通过  Java 对象和  Statement 中 SQL 的动态参数进行映射生成最终要执行的 SQL 语句。\r\n\r\n- 最后 MyBatis 框架执行完 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC API 底层访问细节，使我们不用与 JDBC API 打交道，就可以 完成对数据库的持久化操作。\r\n\r\n- MyBatis 官网：http://www.mybatis.org/mybatis-3/\r\n\r\n### MyBatis 入门程序\r\n\r\n1. 数据准备。\r\n\r\n   ```java\r\n   数据库表：student，表字段 id name age\r\n   \r\n   bean包下Student类，private Integer id; private String name; private Integer age;\r\n   \r\n   准备一个测试类：\r\n      		//查询全部\r\n         @Test\r\n         public void selectAll() {\r\n         //1.加载核心配置文件\r\n         //2.获取SqLSession工厂对象\r\n         //3.通过SqLSession工厂对象获取SqISession对象\r\n         //4.执行映射配置文件中的sqL语句，并接收结果\r\n         //5.处理结果\r\n         //6.释放资源\r\n         }\r\n   ```\r\n\r\n   \r\n\r\n2. 导入 mybatis-3.5.3.jar、mysql-connector-java-5.1.37-bin.jar包。\r\n\r\n3. 在  src 下创建映射配置文件-StudentMapper.xml。\r\n\r\n4. 在  src 下创建核心配置文件-MyBatisConfig.xml。\r\n\r\n5. 编写测试类完成相关  API 的使用。\r\n\r\n6. 运行测试查看结果。\r\n\r\n## MyBatis 相关 API\r\n\r\n### Resources\r\n\r\n- org.apache.ibatis.io.Resources：加载资源的工具类。\r\n\r\n- 核心方法\r\n\r\n  | 返回值      | 方法名                               | 说明                                 |\r\n  | ----------- | ------------------------------------ | ------------------------------------ |\r\n  | InputStream | getResourceAsStream(String fileName) | 通过类加载器返回指定资源的字节输入流 |\r\n\r\n### SqlSessionFactoryBuilder\r\n\r\n- org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类。\r\n\r\n- 核心方法\r\n\r\n  | 返回值            | 方法名                | 说明                                         |\r\n  | ----------------- | --------------------- | -------------------------------------------- |\r\n  | SqlSessionFactory | build(InputStream is) | 通过指定资源字节输入流获取SqlSession工厂对象 |\r\n\r\n  \r\n\r\n### SqlSessionFactory\r\n\r\n- org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\r\n\r\n- 核心方法\r\n\r\n  | 返回值     | 方法名                          | 说明                                                         |\r\n  | ---------- | ------------------------------- | ------------------------------------------------------------ |\r\n  | SqlSession | openSession()                   | 获取SqlSession构建者对象，并开启手动提交事务                 |\r\n  | SqlSession | openSession(boolean autoCommit) | 获取SqlSession构建者对象，如果参数为true，则开启自动提交事务 |\r\n\r\n### SqlSession\r\n\r\n- org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\r\n\r\n| 返回值  | 方法名                                       | 说明                           |\r\n| ------- | -------------------------------------------- | ------------------------------ |\r\n| List<E> | selectList(String statement,Object paramter) | 执行查询语句，返回List集合     |\r\n| T       | selectOne(String statement,Object paramter)  | 执行查询语句，返回一个结果对象 |\r\n| int     | insert(String statement,Object paramter)     | 执行新增语句，返回影响行数     |\r\n| int     | update(String statement,Object paramter)     | 执行修改语句，返回影响行数     |\r\n| int     | delete(String statement,Object paramter)     | 执行删除语句，返回影响行数     |\r\n| void    | commit()                                     | 提交事务                       |\r\n| void    | rollback()                                   | 回滚事务                       |\r\n| T       | getMapper(Class<T> cls)                      | 获取指定接口的代理实现类对象   |\r\n| void    | close()                                      | 释放资源                       |\r\n\r\n\r\n\r\n## MyBatis 映射配置文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!--MyBatis的DTD约束-->\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n\r\n<!--\r\n    mapper：核心根标签\r\n    namespace属性：名称空间\r\n-->\r\n<mapper namespace=\"StudentMapper\">\r\n    <!--\r\n        select：查询功能的标签、<insert>：新增功能标签、<update>：修改功能标签、<delete>：删除功能标签\r\n        id属性：唯一标识\r\n        resultType属性：指定结果映射对象类型\r\n        parameterType属性：指定参数映射对象类型\r\n        SQL 获取参数:\r\n        #{属性名}\r\n    -->\r\n    <select id=\"selectAll\" resultType=\"student\">\r\n        SELECT * FROM student\r\n    </select>\r\n\r\n    <select id=\"selectById\" resultType=\"student\" parameterType=\"int\">\r\n        SELECT * FROM student WHERE id = #{id}\r\n    </select>\r\n\r\n    <insert id=\"insert\" parameterType=\"student\">\r\n        INSERT INTO student VALUES (#{id},#{name},#{age})\r\n    </insert>\r\n\r\n    <update id=\"update\" parameterType=\"student\">\r\n        UPDATE student SET name = #{name},age = #{age} WHERE id = #{id}\r\n    </update>\r\n\r\n    <delete id=\"delete\" parameterType=\"int\">\r\n        DELETE FROM student WHERE id = #{id}\r\n    </delete>\r\n</mapper>\r\n```\r\n\r\n## MyBatis 核心配置文件\r\n\r\njdbc.properties\r\n\r\n```mysql\r\ndriver=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost/db1\r\nusername=root\r\npassword=root\r\n```\r\n\r\nMyBatisConfig.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!--MyBatis的DTD约束-->\r\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n\r\n<!--configuration 核心根标签-->\r\n<configuration>\r\n    <!--引入数据库连接的配置文件-->\r\n    <properties resource=\"jdbc.properties\"/>\r\n    <!--配置LOG4J-->\r\n    <settings>\r\n        <setting name=\"logImpl\" value=\"log4j\"/>\r\n    </settings>\r\n    <!--起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"plus.axz.bean.Student\" alias=\"student\"/>\r\n        <!--<package name=\"plus.axz.bean\"/>-->\r\n    </typeAliases>\r\n    <!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个-->\r\n    <environments default=\"mysql\">\r\n        <!--environment配置数据库环境  id属性唯一标识-->\r\n        <environment id=\"mysql\">\r\n            <!-- transactionManager事务管理。  type属性，采用JDBC默认的事务-->\r\n            <transactionManager type=\"JDBC\"></transactionManager>\r\n            <!-- dataSource数据源信息   type属性 连接池-->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- property获取数据库连接的配置信息 -->\r\n                <property name=\"driver\" value=\"${driver}\" />\r\n                <property name=\"url\" value=\"${url}\" />\r\n                <property name=\"username\" value=\"${username}\" />\r\n                <property name=\"password\" value=\"${password}\" />\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n    <!-- mappers引入映射配置文件 -->\r\n    <mappers>\r\n        <!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 -->\r\n        <mapper resource=\"StudentMapper.xml\"/>\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n数据库连接配置文件引入\r\n\r\n- <properties>：引入数据库连接配置文件标签。\r\n- 属性\r\n  resource：数据库连接配置文件路径\r\n- 获取数据库连接参数 \r\n  ${键名}\r\n\r\n起别名\r\n\r\n- <typeAliases>：为全类名起别名的父标签。\r\n- <typeAlias>：为全类名起别名的子标签。\r\n- 属性\r\n  type：指定全类名 \r\n  alias：指定别名\r\n- <package>：为指定包下所有类起别名的子标签。(别名就是类名)\r\n\r\n```java\r\n    <!--起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"plus.axz.bean.Student\" alias=\"student\"/>\r\n        <!--<package name=\"p.bean\"/>-->\r\n    </typeAliase\r\n```\r\n\r\n| 别名    | 数据类型          |\r\n| ------- | ----------------- |\r\n| string  | java.lang.String  |\r\n| long    | java.lang.Long    |\r\n| int     | java.lang.Integer |\r\n| double  | java.lang.Double  |\r\n| boolean | java.lang.Boolean |\r\n\r\n### 核心配置文件小结\r\n\r\n- 核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\r\n- <configuration>：核心根标签。\r\n- <properties>：引入数据库连接信息配置文件标签。\r\n- <typeAliases>：起别名标签。\r\n- <environments>：配置数据库环境标签。\r\n- <environment>：配置数据库信息标签。\r\n- <transactionManager>：事务管理标签。\r\n- <dataSource>：数据源标签。\r\n- <property>：数据库连接信息标签。\r\n- <mappers>：引入映射配置文件标签。\r\n\r\n## MyBatis 传统方式实现 Dao 层-进阶\r\n\r\n### Dao 层传统实现方式\r\n\r\n- 分层思想：控制层(controller)、业务层(service)、持久层(dao)。\r\n- 调用流程\r\n\r\n控制层->业务层->持久层->DB\r\n\r\n### LOG4J\r\n\r\n- 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的  SQL 语句、参数、结果等信息，可以借助  LOG4J 的功能来实现执行信息的输出。\r\n- 使用步骤\r\n\r\n1. 导入log4j-1.2.17.jar包。\r\n\r\n2. 修改核心配置文件 MyBatisConfig.xml 添加：\r\n\r\n   ```xml\r\n   <!--集成L0G4J日志信息-->\r\n   <settings>\r\n   		<setting name=\"logImpl\" value= \"log4j\"/>\r\n   </settings>\r\n   ```\r\n\r\n3. 在  src 下编写  LOG4J 配置文件。\r\n\r\n```xml\r\n# 输出等级  ERROR WARN INFO DEBUG   # stdout把信息输出到控制台上\r\nlog4j.rootLogger=DEBUG, stdout\r\n# 输出格式\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n\r\n\r\n## MyBatis 接口代理方式实现 Dao 层\r\n\r\n### 接口代理方式-实现规则\r\n\r\n- 传统方式实现 Dao 层，我们既要写接口，还要写实现类。而 MyBatis 框架可以帮助我们省略编写 Dao 层接口实现类的步骤。程序员只需要编写接口，由 MyBatis 框架根据接口的定义来创建该接口的动态代理对象。\r\n\r\n- **实现规则**\r\n\r\n  ​	**映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。**\r\n\r\n### 接口代理方式-代码实现\r\n\r\n1.  删除 mapper 层接口的实现类。\r\n2.  修改映射配置文件。\r\n3.  修改 service 层接口的实现类，采用接口代理方式实现功能。\r\n\r\n### 接口代理方式-源码分析\r\n\r\n- 分析动态代理对象如何生成的？\r\n  通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。\r\n- 分析方法是如何执行的？\r\n  动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的SqlSession 方式来执行增删改查。\r\n\r\n### 接口代理方式小结\r\n\r\n- 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。\r\n\r\n- 实现规则\r\n\r\n  ​	映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。\r\n\r\n- 获取动态代理对象\r\n  SqlSession 功能类中的 getMapper() 方法。\r\n\r\n## MyBatis 映射配置文件 – 动态 SQL\r\n\r\nMyBatis 映射配置文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 就是 \r\n动态变化的，此时在前面学习的 SQL 就不能满足要求了。\r\n\r\n- 多条件查询\r\n\r\n​		id:3 name:萧萧 age:25\r\n\r\n​		SELECT * FROM student WHERE id = ? AND name = ? AND age = ?\r\n\r\n​		id:3 name:萧萧\r\n\r\n​		SELECT * FROM student WHERE id = ? AND name = ?\r\n\r\n- 动态 SQL 标签\r\n  <if>：条件判断标签。 \r\n  <foreach>：循环遍历标签。\r\n\r\n### if标签\r\n\r\n- <where>：条件标签。如果有动态条件，则使用该标签代替 where 关键字。\r\n\r\n- <if>：条件判断标签。\r\n\r\n  ```sql\r\n  <if test=\"条件判断\"> \r\n  查询条件拼接\r\n  </if>\r\n  ```\r\n\r\n### foreach标签\r\n\r\n- <foreach>：循环遍历标签。适用于多个参数或者的关系。\r\n\r\n  ```sql\r\n  <foreach collection=\"\" open=\"\" close=\"\"item=\"\"separator=\"\"> \r\n  		获取参数\r\n  </foreach>\r\n  ```\r\n\r\n- 属性\r\n\r\n  > collection：参数容器类型，(list-集合，array-数组)。 \r\n  > open：开始的 SQL 语句。\r\n  > close：结束的 SQL 语句。 \r\n  > item：参数变量名。 \r\n  > separator：分隔符。\r\n\r\n### SQL 片段抽取\r\n\r\n- 我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。\r\n\r\n  ```sql\r\n  <sql>：抽取 SQL 语句标签。\r\n  <sql id=\"片段唯一标识\">抽取的 SQL 语句</sql>\r\n  \r\n  <include>：引入 SQL 片段标签。\r\n  <include refid=\"片段唯一标识\"/>\r\n  ```\r\n\r\n### 动态  SQL 小结\r\n\r\n动态 SQL 指的就是 SQL 语句可以根据条件或者参数的不同进行动态的变化。\r\n\r\n> <where>：条件标签。\r\n> <if>：条件判断的标签。\r\n> <foreach>：循环遍历的标签。\r\n> <sql>：抽取 SQL 片段的标签。\r\n> <include>：引入 SQL 片段的标签。\r\n\r\n\r\n\r\n## MyBatis 核心配置文件 – 分页插件\r\n\r\n分页插件介绍：\r\n\r\n- 分页可以将很多条结果进行分页显示。\r\n\r\n- 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。\r\n\r\n- 需要明确当前是第几页，这一页中显示多少条结果。\r\n- 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 \r\n  功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 \r\n  成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。\r\n- PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。\r\n\r\n\r\n\r\n### 分页插件实现步骤\r\n\r\n1.  导入 jar 包。\r\n2.  在核心配置文件中集成分页助手插件。\r\n3.  在测试类中使用分页助手相关 API 实现分页功能。\r\n\r\n\r\n\r\n### 分页插件相关参数\r\n\r\n- PageInfo：封装分页相关参数的功能类。\r\n\r\n- 核心方法\r\n\r\n| 返回值  | 方法名          | 说明               |\r\n| ------- | --------------- | ------------------ |\r\n| long    | getTotal()      | 获取总条数         |\r\n| int     | getPages()      | 获取总页数         |\r\n| int     | getPageNum()    | 获取当前页         |\r\n| int     | getPageSize()   | 获取每页显示条数   |\r\n| int     | getPrePage()    | 获取上一页         |\r\n| int     | getNextPage()   | 获取下一页         |\r\n| boolean | isIsFirstPage() | 获取是否是第一页   |\r\n| boolean | isIsLastPage()  | 获取是否是最后一页 |\r\n\r\n### 分页插件小结\r\n\r\n- 分页：可以将很多条结果进行分页显示。\r\n\r\n- 分页插件 jar 包：pagehelper-5.1.10.jar        jsqlparser-3.1.jar\r\n\r\n- <plugins>：集成插件标签。\r\n\r\n- 分页助手相关 API\r\n\r\n  > PageHelper：分页助手功能类。 \r\n  > 		startPage()：设置分页参数\r\n  > PageInfo：分页相关参数功能类。\r\n  > 		getTotal()：获取总条数\r\n  > 		getPages()：获取总页数\r\n  > 		getPageNum()：获取当前页\r\n  > 		getPageSize()：获取每页显示条数\r\n  > 		getPrePage()：获取上一页\r\n  > 		getNextPage()：获取下一页 \r\n  > 		isIsFirstPage()：获取是否是第一页 \r\n  > 		isIsLastPage()：获取是否是最后一页\r\n\r\n## 多表模型\r\n\r\n- 多表模型分类\r\n  	一对一：在任意一方建立外键，关联对方的主键。 \r\n  	一对多：在多的一方建立外键，关联一的一方的主键。\r\n  	多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。\r\n\r\n一对一\r\n		一对一模型：人和身份证，一个人只有一个身份证。\r\n		环境准备\r\n\r\n```sql\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <association>：配置被包含对象的映射关系标签。 \r\nproperty 属性：被包含对象的变量名 \r\njavaType 属性：被包含对象的数据类型\r\n```\r\n\r\n一对多\r\n	一对多模型：班级和学生，一个班级可以有多个学生。\r\n	环境准备。\r\n\r\n```sql\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n多对多\r\n	多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。\r\n	环境准备。\r\n\r\n```\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n### 多表操作小结\r\n\r\n```\r\n多表模型分类：一对一、一对多、多对多。\r\n    <resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称 \r\nproperty 属性： 实体对象变量名称\r\n    <association>：配置被包含对象的映射关系标签。 \r\nproperty 属性：被包含对象的变量名 \r\njavaType 属性：被包含对象的数据类型\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n## MyBatis 注解开发\r\n\r\n常用注解介绍\r\n\r\n- 我们除了可以使用映射配置文件来操作以外，还可以使用注解形式来操作。\r\n  - 常用注解\r\n    @Select(“查询的 SQL 语句”)：执行查询操作注解 \r\n    @Insert(“新增的 SQL 语句”)：执行新增操作注解 \r\n    @Update(“修改的 SQL 语句”)：执行修改操作注解 \r\n    @Delete(“删除的 SQL 语句”)：执行删除操作注解\r\n\r\n注解实现查询操作\r\n\r\n- 创建接口和查询方法\r\n\r\n- 在核心配置文件中配置映射关系\r\n\r\n  ```\r\n  <mappers>\r\n  	<package name =\"接口所在包\"/>\r\n  </mappers>\r\n  ```\r\n\r\n  \r\n\r\n- 编写测试类\r\n\r\n注解实现修改操作\r\n\r\n- 创建修改方法\r\n\r\n- 编写测试类\r\n\r\n注解实现删除操作\r\n\r\n- 创建删除方法\r\n- 编写测试类\r\n\r\n\r\n\r\n\r\n\r\n## MyBatis 注解实现多表操作\r\n\r\n一对一\r\n\r\n```sql\r\n环境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\none 属性：一对一查询固定属性\r\n    @One：一对一查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n一对多\r\n\r\n```sql\r\n境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\nmany 属性：一对多查询固定属性\r\n    @Many：一对多查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n多对多\r\n\r\n```sql\r\n环境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\nmany 属性：一对多查询固定属性\r\n    @Many：一对多查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n### 注解多表操作小结\r\n\r\n- @Results：封装映射关系的父注解。 \r\n  	Result[] value()：定义了 Result 数组\r\n\r\n- @Result：封装映射关系的子注解。 \r\n\r\n  ​	column 属性：查询出的表中字段名称 \r\n  ​	property 属性：实体对象中的属性名称 \r\n  ​	javaType 属性：被包含对象的数据类型 \r\n  ​	one 属性：一对一查询固定属性 \r\n  ​	many 属性：一对多查询固定属性\r\n\r\n- @One：一对一查询的注解。\r\n\r\n  ​	select 属性：指定调用某个接口中的方法\r\n\r\n- @Many：一对多查询的注解。\r\n\r\n  ​	select 属性：指定调用某个接口中的方法\r\n\r\n### SQL 构建对象介绍\r\n\r\n我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。\r\nMyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句。\r\n\r\n| 方法名                              | 说明                         |\r\n| ----------------------------------- | ---------------------------- |\r\n| SELECT(String…column)               | 根据字段拼接查询语句         |\r\n| FROM(String…table)                  | 根据表名拼接语句             |\r\n| WHERE(String…condition)             | 根据条件拼接语句             |\r\n| INSERT_INTO(String table)           | 根据表名拼接新增语句         |\r\n| VALUES(String column,String values) | 根据字段和值拼接插入数据语句 |\r\n| UPDATE(String table)                | 根据表名拼接修改语句         |\r\n| DELETE_FROM(String table)           | 根据表名拼接删除语句         |\r\n\r\n### MyBatis 构建 SQL 语句\r\n\r\n#### 查询操作\r\n\r\n- 定义功能类并提供获取查询的 SQL 语句的方法。\r\n\r\n- @SelectProvider：生成查询用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n#### 新增操作\r\n\r\n- 定义功能类并提供获取新增的 SQL 语句的方法。\r\n- @InsertProvider：生成新增用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n\r\n\r\n#### 修改操作\r\n\r\n- 定义功能类并提供获取修改的 SQL 语句的方法。\r\n\r\n- @UpdateProvider：生成修改用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n#### 删除操作\r\n\r\n- 定义功能类并提供获取删除的 SQL 语句的方法。\r\n- @DeleteProvider：生成删除用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n\r\n\r\n### 构建SQL 语句小结\r\n\r\n```sql\r\norg.apache.ibatis.jdbc.SQL：构建 SQL 语句的功能类。通过一些方法来代替 SQL 语句的关键字。 \r\n    SELECT()\r\n    FROM() \r\n    WHERE() \r\n    INSERT_INTO() \r\n    VALUES() \r\n    UPDATE() \r\n    DELETE_FROM()\r\n@SelectProvider：生成查询用的 SQL 语句注解。\r\n@InsertProvider：生成新增用的 SQL 语句注解。\r\n@UpdateProvider：生成修改用的 SQL 语句注解。\r\n@DeleteProvider：生成删除用的 SQL 语句注解。 \r\n    type 属性：生成 SQL 语句功能类对象 \r\n    method 属性：指定调用方法\r\n```', 'java,mybatis,mysql', 1675746091492, 1675746091492, 0, 0, 3, 2, 0, 1, 0);
INSERT INTO `question` VALUES (5, '关于spring cloud nacos注册中心搭建', '# spring cloud nacos注册中心搭建\r\n\r\nNacos是阿里的一个开源产品，它是针对微服务架构中的服务发现、配置管理、服务治理的综合型解决方案。\r\n官方介绍是这样的：\r\n\r\n> Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您实现动态服务\r\n> 发现、服务配置管理、服务及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。\r\n> Nacos 是构建以“服务”为中心的现代应用架构的服务基础设施。\r\n\r\n官网地址：https://nacos.io\r\n\r\n官方文档：https://nacos.io/zh-cn/docs/what-is-nacos.html\r\n\r\nNacos主要提供以下四大功能：\r\n\r\n1. 服务发现与服务健康检查\r\n   Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防\r\n   止向不健康的主机或服务实例发送请求。\r\n2. 动态配置管理\r\n   动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新\r\n   部署应用程序，这使配置的更改更加高效和灵活。\r\n3. 动态DNS服务\r\n   Nacos提供基于DNS 协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以\r\n   域名的方式暴露端点，让三方应用方便的查阅及发现。\r\n4. 服务和元数据管理\r\n   Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周\r\n   期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。\r\n\r\n## 虚拟机镜像准备\r\n\r\n## 安装Nacos Server\r\n\r\n在liunx下安装nacos必须先安装jdk8+才能运行\r\n\r\n可以从https://github.com/alibaba/nacos/releases下载 `nacos -server-$version.zip` 包\r\n\r\n下载后解压：\r\n\r\n```shell\r\nunzip nacos‐server‐$version.zip \r\n或者 \r\ntar ‐zxvf nacos‐server‐$version.tar.gz\r\n```\r\n\r\n进入安装程序的bin目录：\r\n\r\n```\r\n修改vi startup.sh 中的Java路径：\r\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=$HOME/jdk/java\r\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=/usr/local/java/jdk1.8.0_261\r\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=/opt/taobao/java\r\n[ ! -e \"$JAVA_HOME/bin/java\" ] && unset JAVA_HOME\r\n\r\n如果权限不够：chmod u+x /usr/local/software/nacos/bin/*.sh\r\n\r\n启动命令\r\nsh startup.sh  -m standalone 当关闭窗口之后，Nacos服务会自动退出。\r\n\r\n建议使用以下l\r\nsh startup.sh -m standalone & \r\nsetsid sh startup.sh -m standalone &\r\n\r\n查看启动状态\r\nsystemctl status nacos.service\r\n```\r\n\r\n如果您使用的是ubuntu系统，或者运行脚本报错提示符号找不到，可尝试如下运行：\r\n\r\n```\r\nbash startup.sh  -m standalone\r\n```\r\n\r\n如果是Windows，启动命令：\r\n\r\n```\r\ncmd startup.cmd  或者双击  startup.cmd 运行文件 \r\n```\r\n\r\n启动成功，可通过浏览器访问 http://ip地址:8848/nacos ，打开nacos控制台登录页面：\r\n\r\n\r\n\r\n开机自启：\r\n\r\n创建nacos.service文件：\r\n\r\n```shell\r\nvi /lib/systemd/system/nacos.service\r\n```\r\n\r\n填写内容:\r\n\r\n```shell\r\n[Unit]\r\nDescription=nacos\r\nAfter=network.target\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/local/software/nacos/bin/startup.sh -m standalone\r\nExecReload=/usr/local/software/nacos/bin/shutdown.sh\r\nExecStop=/usr/local/software/nacos/bin/shutdown.sh\r\nPrivateTmp=true\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n在重载服务\r\n\r\n```shell\r\nsystemctl daemon-reload\r\n```\r\n\r\n在设置开机启动\r\n\r\n```shell\r\nsystemctl enable nacos.service\r\n```\r\n\r\n\r\n\r\n## 注册服务\r\n\r\n```xml\r\n父类添加：	\r\n						<com.alibaba.cloud>2.1.0.RELEASE</com.alibaba.cloud>\r\n							<!--spring cloud alibaba-->\r\n            <dependency>\r\n                <groupId>com.alibaba.cloud</groupId>\r\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\r\n                <version>${com.alibaba.cloud}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n```\r\n\r\n在admin微服务中加入依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n在admin微服务中的application.yml文件中加入配置\r\n\r\n```xml\r\nspring:\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: ip地址:8848\r\n```\r\n\r\n引导类中加上注解`@EnableDiscoveryClient`可以让该服务注册到nacos注册中心上去\r\n\r\n启动admin微服务，启动nacos，可以查看到admin服务已经在服务列表中了', 'springcloud', 1675746115929, 1675746251457, 0, 0, 10, 2, 0, 1, 0);
INSERT INTO `question` VALUES (6, 'SpringBoot集成Swagger和knife4j', '# SpringBoot集成Swagger\r\n\r\n(1)简介\r\n\r\nSwagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(https://swagger.io/)。 它的主要作用是：\r\n\r\n1. 使得前后端分离开发更加方便，有利于团队协作\r\n2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担\r\n3. 功能测试 \r\n\r\nSpring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。\r\n\r\n(2)SpringBoot集成Swagger\r\n\r\n- 引入依赖,在model模块中引入该依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>io.springfox</groupId>\r\n    <artifactId>springfox-swagger2</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.springfox</groupId>\r\n    <artifactId>springfox-swagger-ui</artifactId>\r\n</dependency>\r\n```\r\n\r\n只需要在common中进行配置即可，因为其他微服务工程都直接或间接依赖即可。\r\n\r\n- 在admin工程的config包中添加一个配置类\r\n\r\n```java\r\npackage com.axz.admin.config;\r\n\r\nimport com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;\r\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Import;\r\nimport springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;\r\nimport springfox.documentation.builders.ApiInfoBuilder;\r\nimport springfox.documentation.builders.PathSelectors;\r\nimport springfox.documentation.builders.RequestHandlerSelectors;\r\nimport springfox.documentation.service.ApiInfo;\r\nimport springfox.documentation.service.Contact;\r\nimport springfox.documentation.spi.DocumentationType;\r\nimport springfox.documentation.spring.web.plugins.Docket;\r\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\r\n\r\n@Configuration\r\n@EnableSwagger2\r\n@EnableKnife4j\r\n@Import(BeanValidatorPluginsConfiguration.class)\r\npublic class Swagger2Configuration {\r\n\r\n    @Bean(value = \"defaultApi2\")\r\n    public Docket defaultApi2() {\r\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                //分组名称\r\n                .groupName(\"xiao-blog接口1.0\")\r\n                .select()\r\n                //这里指定Controller扫描包路径\r\n                .apis(RequestHandlerSelectors.basePackage(\"plus.axz\"))\r\n                .paths(PathSelectors.any())\r\n                .build();\r\n        return docket;\r\n    }\r\n    private ApiInfo apiInfo() {\r\n        return new ApiInfoBuilder()\r\n                .title(\"xiao-博客API文档\")\r\n                .contact(new Contact(\"xiaoxiang\",\"http://0916.pro\",\"1056965430@qq.com\"))\r\n                .license(\"xiaoxiang\")\r\n                .licenseUrl(\"http://0916.pro\")\r\n                .description(\"xiao-博客API文档\")\r\n                .version(\"1.0\")\r\n                .build();\r\n    }\r\n}\r\n```\r\n\r\n（3）Swagger常用注解\r\n\r\n在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：\r\n\r\n@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数的描述信息 \r\n\r\n@ApiModel：用对象来接收参数 \r\n\r\n@ApiModelProperty：用对象接收参数时，描述对象的一个字段 \r\n\r\n@ApiResponse：HTTP响应其中1个描述 \r\n\r\n@ApiResponses：HTTP响应整体描述 \r\n\r\n@ApiIgnore：使用该注解忽略这个API \r\n\r\n@ApiError ：发生错误返回的信息 \r\n\r\n@ApiImplicitParam：一个请求参数 \r\n\r\n@ApiImplicitParams：多个请求参数的描述信息\r\n\r\n@ApiImplicitParam属性：\r\n\r\n| 属性         | 取值   | 作用                                          |\r\n| ------------ | ------ | --------------------------------------------- |\r\n| paramType    |        | 查询参数类型                                  |\r\n|              | path   | 以地址的形式提交数据                          |\r\n|              | query  | 直接跟参数完成自动映射赋值                    |\r\n|              | body   | 以流的形式提交 仅支持POST                     |\r\n|              | header | 参数在request headers 里边提交                |\r\n|              | form   | 以form表单的形式提交 仅支持POST               |\r\n| dataType     |        | 参数的数据类型 只作为标志说明，并没有实际验证 |\r\n|              | Long   |                                               |\r\n|              | String |                                               |\r\n| name         |        | 接收参数名                                    |\r\n| value        |        | 接收参数的意义描述                            |\r\n| required     |        | 参数是否必填                                  |\r\n|              | true   | 必填                                          |\r\n|              | false  | 非必填                                        |\r\n| defaultValue |        | 默认值                                        |\r\n\r\n在TagControllerApi中添加Swagger注解，代码如下所示：\r\n\r\n```java\r\npackage com.axz.apis.admin;\r\n\r\nimport com.axz.model.admin.dtos.TagDto;\r\nimport com.axz.model.admin.pojos.Tag;\r\nimport com.axz.model.common.dtos.ResponseResult;\r\nimport io.swagger.annotations.Api;\r\nimport io.swagger.annotations.ApiOperation;\r\n\r\n@Api(value = \"标签管理\", tags = \"tag\", description = \"标签管理API\")\r\npublic interface TagControllerApi {\r\n\r\n    /**\r\n     * 根据名称分页查询标签列表\r\n     * @param dto\r\n     * @return\r\n     */\r\n    @ApiOperation(\"标签分页列表查询\")\r\n    public ResponseResult findByNameAndPage(TagDto dto);\r\n\r\n    /**\r\n     * 新增\r\n     * @param tag\r\n     * @return\r\n     */\r\n    @ApiOperation(\"新增标签\")\r\n    public ResponseResult save(Tag tag);\r\n\r\n    /**\r\n     * 修改\r\n     * @param tag\r\n     * @return\r\n     */\r\n    @ApiOperation(\"修改标签\")\r\n    public ResponseResult update(Tag tag);\r\n\r\n    /**\r\n     * 删除\r\n     * @param id\r\n     * @return\r\n     */\r\n    @ApiOperation(\"删除标签\")\r\n    public ResponseResult deleteById(Integer id);\r\n}\r\n```\r\n\r\nTagDto\r\n\r\n```Java\r\npackage com.axz.model.admin.dtos;\r\n\r\nimport com.axz.model.common.dtos.PageRequestDto;\r\nimport io.swagger.annotations.ApiModelProperty;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Data/*重写get、set方法*/\r\n@Builder\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class TagDto extends PageRequestDto {\r\n    /*接收三个参数---频道名称-当前页-每页显示条数*/\r\n    /*通过继承PageRequestDto，接收当前页-每页显示条数*/\r\n    /**\r\n     * 标签名称\r\n     */\r\n    @ApiModelProperty(\"标签名称\")/*描述当前接收参数的信息，，比如该name就是指标签名称*/\r\n    private String tag_name;\r\n}\r\n```\r\n\r\nPageRequestDto\r\n\r\n```Java\r\npackage com.axz.model.common.dtos;\r\n\r\nimport io.swagger.annotations.ApiModelProperty;\r\nimport lombok.Data;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Data\r\n@Slf4j\r\npublic class PageRequestDto {\r\n\r\n    @ApiModelProperty(value=\"每页显示条数\",required = true)/*required 参数必须要传*/\r\n    protected Integer size;\r\n    @ApiModelProperty(value=\"当前页\",required = true)\r\n    protected Integer page;\r\n\r\n    public void checkParam() {\r\n        if (this.page == null || this.page < 0) {/*等于null或者小于0,赋予默认值第1页*/\r\n            setPage(1);\r\n        }\r\n        if (this.size == null || this.size < 0 || this.size > 100) {/*等于null或者小于0或大于100,赋予默认值10条数据*/\r\n            setSize(10);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n启动admin微服务，访问地址：http://localhost:端口号/swagger-ui.html\r\n\r\n\r\n\r\n# SpringBoot集成knife4j\r\n\r\n(1)简介\r\n\r\nknife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!\r\n\r\ngitee地址：https://gitee.com/xiaoym/knife4j\r\n\r\n官方文档：https://doc.xiaominfo.com/\r\n\r\n效果演示：http://knife4j.xiaominfo.com/doc.html\r\n\r\n(2)核心功能\r\n\r\n该UI增强包主要包括两大核心功能：文档说明 和 在线调试\r\n\r\n- 文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。\r\n- 在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。\r\n- 个性化配置：通过个性化ui配置项，可自定义UI的相关显示信息\r\n- 离线文档：根据标准规范，生成的在线markdown离线文档，开发者可以进行拷贝生成markdown接口文档，通过其他第三方markdown转换工具转换成html或pdf，这样也可以放弃swagger2markdown组件\r\n- 接口排序：自1.8.5后，ui支持了接口排序功能，例如一个注册功能主要包含了多个步骤,可以根据swagger-bootstrap-ui提供的接口排序规则实现接口的排序，step化接口操作，方便其他开发者进行接口对接\r\n\r\n(3)快速集成\r\n\r\n- 在common模块中的`pom.xml`文件中引入`knife4j`的依赖,如下：\r\n\r\n```\r\n<dependency>\r\n     <groupId>com.github.xiaoymin</groupId>\r\n     <artifactId>knife4j-spring-boot-starter</artifactId>\r\n</dependency>\r\n```\r\n\r\n- 创建Swagger配置文件\r\n\r\n在common模块中新建配置类\r\n\r\n新建Swagger的配置文件`SwaggerConfiguration.java`文件,创建springfox提供的Docket分组对象,代码如下：\r\n\r\n```java\r\npackage com.axz.common.knife4j;\r\n\r\nimport com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Import;\r\nimport springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;\r\nimport springfox.documentation.builders.ApiInfoBuilder;\r\nimport springfox.documentation.builders.PathSelectors;\r\nimport springfox.documentation.builders.RequestHandlerSelectors;\r\nimport springfox.documentation.service.ApiInfo;\r\nimport springfox.documentation.spi.DocumentationType;\r\nimport springfox.documentation.spring.web.plugins.Docket;\r\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\r\n\r\n@Configuration\r\n@EnableSwagger2\r\n@EnableKnife4j\r\n@Import(BeanValidatorPluginsConfiguration.class)\r\npublic class Swagger2Configuration {\r\n\r\n    @Bean(value = \"defaultApi2\")\r\n    public Docket defaultApi2() {\r\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                //分组名称\r\n                .groupName(\"1.0\")\r\n                .select()\r\n                //这里指定Controller扫描包路径\r\n                .apis(RequestHandlerSelectors.basePackage(\"com.axz\"))\r\n                .paths(PathSelectors.any())\r\n                .build();\r\n        return docket;\r\n    }\r\n    private ApiInfo apiInfo() {\r\n        return new ApiInfoBuilder()\r\n                .title(\"axz-博客API文档\")\r\n                .description(\"axz-博客API文档\")\r\n                .version(\"1.0\")\r\n                .build();\r\n    }\r\n}\r\n```\r\n\r\n以上有两个注解需要特别说明，如下表：\r\n\r\n| 注解            | 说明                                                         |\r\n| --------------- | ------------------------------------------------------------ |\r\n| @EnableSwagger2 | 该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加 |\r\n| @EnableKnife4j  | 该注解是`knife4j`提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加 |\r\n\r\n- 访问\r\n\r\n在admin中开启配置\r\n\r\n在config包下新建类KnifeConfig\r\n\r\n```java\r\npackage com.axz.admin.config;\r\n\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@ComponentScan(\"com.axz.common.knife4j\")\r\npublic class KnifeConfig {\r\n}\r\n```\r\n\r\n- 访问\r\n\r\n在浏览器输入地址：`http://localhost:端口号/doc.html`', 'springboot', 1675752941189, 1675752941189, 0, 0, 8, 2, 0, 1, 0);
INSERT INTO `question` VALUES (7, '常见加密方式', '# 加密算法种类有:\r\n\r\n## 可逆加密算法\r\n\r\n**解释：**加密后, 密文可以反向解密得到密码原文.\r\n\r\n### 对称加密\r\n\r\n**解释：**文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥\r\n\r\n![image-20211212144728871](常见加密方式.assets/image-20211212144728871.png)\r\n\r\n**解释:**  在对称加密算法中，数据发信方将明文和加密密钥一起经过特殊的加密算法处理后，使其变成复杂的加密密文发送出去，收信方收到密文后，若想解读出原文，则需要使用加密时用的密钥以及相同加密算法的逆算法对密文进行解密，才能使其回复成可读明文。在对称加密算法中，使用的密钥只有一个，收发双方都使用这个密钥，这就需要解密方事先知道加密密钥。\r\n\r\n**优点:** 对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。\r\n\r\n**缺点:** 没有非对称加密安全.\r\n\r\n**用途：** 一般用于保存用户手机号、身份证等敏感但能解密的信息。\r\n\r\n**常见的对称加密算法有**: `AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、HS256`\r\n\r\n### 非对称加密\r\n\r\n两个密钥：公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密\r\n\r\n![image-20211212144851551](常见加密方式.assets/image-20211212144851551.png)\r\n\r\n**解释: ** 同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端.\r\n\r\n加密与解密:\r\n\r\n-  私钥加密，持有公钥才可以解密\r\n-  公钥加密，持有私钥才可解密\r\n\r\n签名:\r\n\r\n-  私钥签名, 持有公钥进行验证是否被篡改过.\r\n\r\n**优点: ** 非对称加密与对称加密相比，其安全性更好；\r\n\r\n**缺点:** 非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\r\n**用途：** 一般用于签名和认证。私钥服务器保存, 用来加密, 公钥客户拿着用于对于令牌或者签名的解密或者校验使用.\r\n\r\n**常见的非对称加密算法有：** `RSA、DSA（数字签名用）、ECC（移动设备用）、RS256 (采用SHA-256 的 RSA 签名)`\r\n\r\n## 不可逆加密算法\r\n\r\n**解释:** 一旦加密就不能反向解密得到密码原文.\r\n\r\n**种类:** Hash加密算法, 散列算法, 摘要算法等\r\n\r\n**用途：**一般用于效验下载文件正确性，一般在网站上下载文件都能见到；存储用户敏感信息，如密码、 卡号等不可解密的信息。\r\n\r\n**常见的不可逆加密算法有：** `MD5、SHA、HMAC`\r\n\r\n## Base64编码\r\n\r\nBase64是网络上最常见的用于传输8Bit字节代码的编码方式之一。Base64编码可用于在HTTP环境下传递较长的标识信息。采用Base64Base64编码解码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。**注意：Base64只是一种编码方式，不算加密方法。**\r\n\r\n在线编码工具：\r\n\r\nhttp://www.jsons.cn/img2base64/\r\n\r\n# 密码加密的方式选型\r\n\r\n## MD5密码加密\r\n\r\nMD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。\r\n\r\n```java\r\n//md5加密  DegestUtils：spring框架提供的工具类\r\nString md5Str = DigestUtils.md5DigestAsHex(\"abc\".getBytes());\r\nSystem.out.println(md5Str);//900150983cd24fb0d6963f7d28e17f72\r\n```\r\n\r\nmd5相同的密码每次加密都一样，不太安全\r\n\r\n##  手动加密（md5+随机字符串）\r\n\r\n在md5的基础上手动加盐（salt）处理\r\n\r\n```Java\r\n//uername:zhangsan  password:123   salt:随时字符串\r\nString salt = RandomStringUtils.randomAlphanumeric(10);//获取一个10位的随机字符串\r\nSystem.out.println(salt);\r\nString pswd = \"123\"+salt;\r\n\r\nString saltPswd = DigestUtils.md5DigestAsHex(pswd.getBytes());\r\nSystem.out.println(saltPswd);\r\n```\r\n\r\n这样同样的密码，加密多次值是不相同的，因为加入了随机字符串\r\n\r\n## BCrypt密码加密\r\n\r\n  在用户模块，对于用户密码的保护，通常都会进行加密。我们通常对密码进行加密，然后存放在数据库中，在用户进行登录的时候，将其输入的密码进行加密然后与数据库中存放的密文进行比较，以验证用户密码是否正确。 目前，MD5和BCrypt比较流行。相对来说，BCrypt比MD5更安全。\r\n\r\nBCrypt 官网http://www.mindrot.org/projects/jBCrypt/\r\n\r\n（1）官网下载源码\r\n\r\n（2）新建工程，将源码类BCrypt拷贝到工程\r\n\r\n（3）新建测试类，main方法中编写代码，实现对密码的加密\r\n\r\n```Java\r\nString gensalt = BCrypt.gensalt();//这个是盐  29个字符，随机生成\r\nSystem.out.println(gensalt);\r\nString password = BCrypt.hashpw(\"123456\", gensalt);  //根据盐对密码进行加密\r\nSystem.out.println(password);//加密后的字符串前29位就是盐\r\n```\r\n\r\n（4）新建测试类，main方法中编写代码，实现对密码的校验。BCrypt不支持反运算，只支持密码校验。\r\n\r\n```Java\r\nboolean checkpw = BCrypt.checkpw(\"123456\",     \"$2a$10$61ogZY7EXsMDWeVGQpDq3OBF1.phaUu7.xrwLyWFTOu8woE08zMIW\");\r\nSystem.out.println(checkpw);\r\n```\r\n\r\n## jwt介绍\r\n\r\n### token认证\r\n\r\n随着 Restful API、微服务的兴起，基于 Token  的认证现在已经越来越普遍。基于token的用户认证是一种**服务端无状态**的认证方式，所谓服务端无状态指的token本身包含登录用户所有的相关数据，而客户端在认证后的每次请求都会携带token，因此服务器端无需存放token数据。\r\n\r\n 当用户认证后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage 等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。\r\n\r\n![image-20211212145829424](常见加密方式.assets/image-20211212145829424.png)\r\n\r\n### 什么是JWT？\r\n\r\n 我们现在了解了基于token认证的交互机制，但令牌里面究竟是什么内容？什么格式呢？市面上基于token的认证方式大都采用的是JWT(Json Web Token)。\r\n\r\n JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。\r\n\r\n**JWT令牌结构：**\r\n\r\nJWT令牌由Header、Payload、Signature三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz\r\n\r\n- Header\r\n\r\n头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC、SHA256或RSA）。\r\n\r\n一个例子：alg算法，typ类型\r\n\r\n```java\r\n{\r\n	\"alg\": \"HS256\"，\r\n	\"typ\": \"JWT\"\r\n}\r\n```\r\n\r\n将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。\r\n\r\n- Payload\r\n\r\n第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比\r\n如：iss（签发者），exp（过期时间戳）， sub（面向的用户）等，也可自定义字段。\r\n此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。\r\n一个例子：\r\n\r\n```java\r\n{\r\n	\"sub\": \"1234567890\"，\r\n	\"name\": \"456\"，\r\n	\"admin\": true\r\n}\r\n```\r\n\r\n最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。\r\n\r\n- Signature\r\n\r\n第三部分是签名，此部分用于防止jwt内容被篡改。\r\n这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明\r\n签名算法进行签名。\r\n一个例子：\r\n\r\n```java\r\nHMACSHA256(\r\nbase64UrlEncode(header) + \".\" +\r\nbase64UrlEncode(payload)，\r\nsecret)\r\n```\r\n\r\nbase64UrlEncode(header)：jwt令牌的第一部分。\r\nbase64UrlEncode(payload)：jwt令牌的第二部分。\r\nsecret：签名所使用的密钥。\r\n\r\n下图中包含一个生成的jwt令牌：\r\n\r\n![image-20211212150615328](常见加密方式.assets/image-20211212150615328.png)\r\n\r\n###  生成token\r\n\r\n需要引入jwt相关依赖\r\n\r\n```java\r\n<dependency>\r\n    <groupId>io.jsonwebtoken</groupId>\r\n    <artifactId>jjwt</artifactId>\r\n</dependency>\r\n```\r\n\r\n工具类\r\n\r\n```java\r\npackage com.axz.utils.common;\r\n\r\nimport io.jsonwebtoken.*;\r\n\r\nimport javax.crypto.SecretKey;\r\nimport javax.crypto.spec.SecretKeySpec;\r\nimport java.util.*;\r\n\r\npublic class AppJwtUtil {\r\n\r\n    // TOKEN的有效期一天（S）\r\n    private static final int TOKEN_TIME_OUT = 3_600;\r\n    // 加密KEY\r\n    private static final String TOKEN_ENCRY_KEY = \"MDk4ZjZiY2Q0N3AXZ2DM3M2NhZGU0ZTgzMjYyN2I0ZjY\";\r\n    // 最小刷新间隔(S)\r\n    private static final int REFRESH_TIME = 300;\r\n\r\n    // 生产ID\r\n    public static String getToken(Long id){\r\n        Map<String, Object> claimMaps = new HashMap<>();\r\n        claimMaps.put(\"id\",id);\r\n        long currentTime = System.currentTimeMillis();\r\n        return Jwts.builder()\r\n                .setId(UUID.randomUUID().toString())//设置id\r\n                .setIssuedAt(new Date(currentTime))  //签发时间\r\n                .setSubject(\"system\")  //说明\r\n                .setIssuer(\"axz\") //签发者信息\r\n                .setAudience(\"app\")  //接收用户\r\n                .compressWith(CompressionCodecs.GZIP)  //数据压缩方式\r\n                .signWith(SignatureAlgorithm.HS512, generalKey()) //加密方式\r\n                .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000))  //过期时间戳\r\n                .addClaims(claimMaps) //cla信息(手动设置的内容)\r\n                .compact();\r\n    }\r\n\r\n    /**\r\n     * 获取token中的claims信息\r\n     *\r\n     * @param token\r\n     * @return\r\n     */\r\n    private static Jws<Claims> getJws(String token) {\r\n            return Jwts.parser()\r\n                    .setSigningKey(generalKey())\r\n                    .parseClaimsJws(token);\r\n    }\r\n\r\n    /**\r\n     * 获取payload body信息\r\n     *\r\n     * @param token\r\n     * @return\r\n     */\r\n    public static Claims getClaimsBody(String token) {\r\n        try {\r\n            return getJws(token).getBody();\r\n        }catch (ExpiredJwtException e){\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取hearder body信息\r\n     *\r\n     * @param token\r\n     * @return\r\n     */\r\n    public static JwsHeader getHeaderBody(String token) {\r\n        return getJws(token).getHeader();\r\n    }\r\n\r\n    /**\r\n     * 是否过期\r\n     *\r\n     * @param claims\r\n     * @return -1：有效，0：有效，1：过期，2：过期\r\n     */\r\n    public static int verifyToken(Claims claims) {\r\n        if(claims==null){\r\n            return 1;\r\n        }\r\n        try {\r\n            claims.getExpiration()\r\n                    .before(new Date());\r\n            // 需要自动刷新TOKEN\r\n            if((claims.getExpiration().getTime()-System.currentTimeMillis())>REFRESH_TIME*1000){\r\n                return -1;\r\n            }else {\r\n                return 0;\r\n            }\r\n        } catch (ExpiredJwtException ex) {\r\n            return 1;\r\n        }catch (Exception e){\r\n            return 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 由字符串生成加密key\r\n     *\r\n     * @return\r\n     */\r\n    public static SecretKey generalKey() {\r\n        byte[] encodedKey = Base64.getEncoder().encode(TOKEN_ENCRY_KEY.getBytes());\r\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\r\n        return key;\r\n    }\r\n\r\n\r\n    //测试\r\n    public static void main(String[] args) {\r\n       /* Map map = new HashMap();\r\n        map.put(\"id\",\"1\");*/\r\n//        System.out.println(AppJwtUtil.getToken(1L));//生成带id的jwt字符串\r\n        //解析生成的jwt字符串\r\n//        Jws<Claims> jws = AppJwtUtil.getJws(\"eyJhbGciOiJIUzUxMiIsInppcCI6IkdaSVAifQ.H4sIAAAAAAAAADXLQQrDIBCF4bvMWqF2jMbcZtQJWCgIYyBtyd0zLrr7H4_vB6_RYINIIUdfkmVPxfpasqVlX211eUXeH4WXBAYaDdhcwPRMGBENyJFVy0cGv-cvopPOrzYddXbv2nz2v1Omrunnrht5jdT1fgAAAA.1y8bFDUMaEU9-M38pLr0bcuxnAdi1TK024mHTMyTx0-B4nZEvXoJkRqDvRF8kL4JU51oFxrIytWNGKa6KmbYuw\");\r\n//        Claims claims = jws.getBody();//从jws中，获取自定义的clqims\r\n//        System.out.println(claims);//{jti=7973c09a-091a-407b-9ba6-3b31f0ed1b37, iat=1639293325, sub=system, iss=axz, aud=app, exp=1639296925, id=1}\r\n//        System.out.println(claims.get(\"id\"));\r\n\r\n    }\r\n\r\n}\r\n```', 'intellij-idea', 1675759875429, 1675759875429, 0, 0, 1, 2, 0, 1, 0);
INSERT INTO `question` VALUES (8, '测试1', '11', '测试', 1675760307412, 1675760307412, 0, 0, 0, 2, 0, 1, 0);
INSERT INTO `question` VALUES (9, '测试2', '22', '测试', 1675760461134, 1675760461134, 0, 0, 0, 2, 0, 1, 0);
INSERT INTO `question` VALUES (10, '测试3', '33', '测试', 1675760503157, 1675760503157, 0, 0, 0, 2, 0, 1, 0);
INSERT INTO `question` VALUES (11, '测试4', '44', '测试', 1675760526667, 1675760526667, 0, 0, 1, 2, 0, 1, 0);
INSERT INTO `question` VALUES (12, '2023/2/7', '|  3 |  3 |\r\n| ------------ | ------------ |\r\n|3   |   3|\r\n| 3  |  3 |', '测试', 1675763373843, 1675763373843, 0, 0, 18, 3, 0, 1, 0);
INSERT INTO `question` VALUES (13, '情人节快乐~', '情人节快乐~\r\n[![情人节快乐](https://search-operate.cdn.bcebos.com/1202c9002c22b5eaf0cdf270c290e8ef.jpg \"情人节快乐\")](https://search-operate.cdn.bcebos.com/1202c9002c22b5eaf0cdf270c290e8ef.jpg \"情人节快乐\")', '生活', 1676516376468, 1676516376468, 2, 0, 35, 1, 1, 0, 0);
INSERT INTO `question` VALUES (15, '2-20', '202020删除', '找bug', 1676905656179, 1676905656179, 0, 0, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (16, '阿里云图片上传', '阿里云上传\r\n\r\n![](http://xiao-xiao.oss-cn-beijing.aliyuncs.com/c74b75ec-800e-40ab-b2a5-34bcbad08039.jpg?Expires=1708929879&OSSAccessKeyId=LTAI5tLUsBPzeq8nF3a4HNWx&Signature=ZlCR0ZINLsMWhBGTfQy%2FdtaflwA%3D)', '测试', 1677393903111, 1677393903111, 0, 0, 0, 1, 0, 0, 0);
INSERT INTO `question` VALUES (17, '关于Eureka', '# Euraka配置详解\r\n\r\nEureka包含四个部分的配置\r\n\r\n1. instance：当前Eureka Instance实例信息配置\r\n2. client：Eureka Client客户端特性配置\r\n3. server：Eureka Server注册中心特性配置\r\n4. dashboard：Eureka Server注册中心仪表盘配置\r\n\r\n## Eureka Instance实例信息配置\r\n\r\nEureka Instance的配置信息全部保存在org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean配置类里，实际上它是com.netflix.appinfo.EurekaInstanceConfig的实现类，替代了netflix的com.netflix.appinfo.CloudInstanceConfig的默认实现。\r\n\r\nEureka Instance的配置信息全部以eureka.instance.xxx的格式配置。\r\n\r\n**配置列表**\r\n\r\n- appname = unknown\r\n\r\n应用名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。\r\n\r\n- appGroupName = null\r\n\r\n应用组名\r\n\r\n- instanceEnabledOnit = false\r\n\r\n实例注册到Eureka上是，是否立刻开启通讯。有时候应用在准备好服务之前需要一些预处理。\r\n\r\n- nonSecurePort = 80\r\n\r\n非安全的端口\r\n\r\n- securePort = 443\r\n\r\n安全端口\r\n\r\n- nonSecurePortEnabled = true\r\n\r\n是否开启非安全端口通讯\r\n\r\n- securePortEnabled = false\r\n\r\n是否开启安全端口通讯\r\n\r\n- leaseRenewalIntervalInSeconds = 30\r\n\r\n实例续约间隔时间\r\n\r\n- leaseExpirationDurationInSeconds = 90\r\n\r\n实例超时时间，表示最大leaseExpirationDurationInSeconds秒后没有续约，Server就认为他不可用了，随之就会将其剔除。\r\n\r\n- virtualHostName = unknown\r\n\r\n虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。\r\n\r\n- instanceId\r\n\r\n注册到eureka上的唯一实例ID，不能与相同appname的其他实例重复。\r\n\r\n- secureVirtualHostName = unknown\r\n\r\n安全虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。\r\n\r\n- metadataMap = new HashMap();\r\n\r\n实例元数据，可以供其他实例使用。比如spring-boot-admin在监控时，获取实例的上下文和端口。\r\n\r\n- dataCenterInfo = new MyDataCenterInfo(DataCenterInfo.Name.MyOwn);\r\n\r\n实例部署的数据中心。如AWS、MyOwn。\r\n\r\n- ipAddress=null\r\n\r\n实例的IP地址\r\n\r\n- statusPageUrlPath = \"/actuator/info\"\r\n\r\n实例状态页相对url\r\n\r\n- statusPageUrl = null\r\n\r\n实例状态页绝对URL\r\n\r\n- homePageUrlPath = \"/\"\r\n\r\n实例主页相对URL\r\n\r\n- homePageUrl = null\r\n\r\n实例主页绝对URL\r\n\r\n- healthCheckUrlUrlPath = \"/actuator/health\"\r\n\r\n实例健康检查相对URL\r\n\r\n- healthCheckUrl = null\r\n\r\n实例健康检查绝对URL\r\n\r\n- secureHealthCheckUrl = null\r\n\r\n实例安全的健康检查绝对URL\r\n\r\n- namespace = \"eureka\"\r\n\r\n配置属性的命名空间（Spring Cloud中被忽略）\r\n\r\n- hostname = null\r\n\r\n主机名,不配置的时候讲根据操作系统的主机名来获取\r\n\r\n- preferIpAddress = false\r\n\r\n是否优先使用IP地址作为主机名的标识\r\n\r\n## Eureka Client客户端特性配置\r\n\r\nEureka Client客户端特性配置是对作为Eureka客户端的特性配置，包括Eureka注册中心，本身也是一个Eureka Client。\r\n\r\nEureka Client特性配置全部在org.springframework.cloud.netflix.eureka.EurekaClientConfigBean中，实际上它是com.netflix.discovery.EurekaClientConfig的实现类，替代了netxflix的默认实现。\r\n\r\nEureka Client客户端特性配置全部以eureka.client.xxx的格式配置。\r\n\r\n**配置列表**\r\n\r\n- enabled=true\r\n\r\n是否启用Eureka client。\r\n\r\n- registryFetchIntervalSeconds=30\r\n\r\n定时从Eureka Server拉取服务注册信息的间隔时间\r\n\r\n- instanceInfoReplicationIntervalSeconds=30\r\n\r\n定时将实例信息（如果变化了）复制到Eureka Server的间隔时间。（InstanceInfoReplicator线程）\r\n\r\n- initialInstanceInfoReplicationIntervalSeconds=40\r\n\r\n首次将实例信息复制到Eureka Server的延迟时间。（InstanceInfoReplicator线程）\r\n\r\n- eurekaServiceUrlPollIntervalSeconds=300\r\n\r\n拉取Eureka Server地址的间隔时间（Eureka Server有可能增减）\r\n\r\n- proxyPort=null\r\n\r\nEureka Server的代理端口\r\n\r\n- proxyHost=null\r\n\r\nEureka Server的代理主机名\r\n\r\n- proxyUserName=null\r\n\r\nEureka Server的代理用户名\r\n\r\n- proxyPassword=null\r\n\r\nEureka Server的代理密码\r\n\r\n- eurekaServerReadTimeoutSeconds=8\r\n\r\n从Eureka Server读取信息的超时时间\r\n\r\n- eurekaServerConnectTimeoutSeconds=5\r\n\r\n连接Eureka Server的超时时间\r\n\r\n- backupRegistryImpl=null\r\n\r\nEureka Client第一次启动时获取服务注册信息的调用的回溯实现。Eureka Client启动时首次会检查有没有BackupRegistry的实现类，如果有实现类，则优先从这个实现类里获取服务注册信息。\r\n\r\n- eurekaServerTotalConnections=200\r\n\r\nEureka client连接Eureka Server的链接总数\r\n\r\n- eurekaServerTotalConnectionsPerHost=50\r\n\r\nEureka client连接单台Eureka Server的链接总数\r\n\r\n- eurekaServerURLContext=null\r\n\r\n当Eureka server的列表在DNS中时，Eureka Server的上下文路径。如http://xxxx/eureka。\r\n\r\n- eurekaServerPort=null\r\n\r\n当Eureka server的列表在DNS中时，Eureka Server的端口。\r\n\r\n- eurekaServerDNSName=null\r\n\r\n当Eureka server的列表在DNS中时，且要通过DNSName获取Eureka Server列表时，DNS名字。\r\n\r\n- region=\"us-east-1\"\r\n\r\n实例所属区域。\r\n\r\n- eurekaConnectionIdleTimeoutSeconds = 30\r\n\r\nEureka Client和Eureka Server之间的Http连接的空闲超时时间。\r\n\r\n- heartbeatExecutorThreadPoolSize=2\r\n\r\n心跳（续约）执行器线程池大小。\r\n\r\n- heartbeatExecutorExponentialBackOffBound=10\r\n\r\n心跳执行器在续约过程中超时后的再次执行续约的最大延迟倍数。默认最大延迟时间=10 * eureka.instance.leaseRenewalIntervalInSeconds\r\n\r\n- cacheRefreshExecutorThreadPoolSize=2\r\n\r\ncacheRefreshExecutord的线程池大小（获取注册信息）\r\n\r\n- cacheRefreshExecutorExponentialBackOffBound=10\r\n\r\ncacheRefreshExecutord的再次执行的最大延迟倍数。默认最大延迟时间=10 *eureka.client.registryFetchIntervalSeconds\r\n\r\n- serviceUrl= new HashMap();serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);\r\n\r\nEureka Server的分区地址。默认添加了一个defualtZone。也就是最常用的配置eureka.client.service-url.defaultZone=xxx\r\n\r\n- registerWithEureka=true\r\n\r\n是否注册到Eureka Server。\r\n\r\n- preferSameZoneEureka=true\r\n\r\n是否使用相同Zone下的Eureka server。\r\n\r\n- logDeltaDiff=false\r\n\r\n是否记录Eureka Server和Eureka Client之间注册信息的差异\r\n\r\n- disableDelta=false\r\n\r\n是否开启增量同步注册信息。\r\n\r\n- fetchRemoteRegionsRegistry=null\r\n\r\n获取注册服务的远程地区，以逗号隔开。\r\n\r\n- availabilityZones=new HashMap()\r\n\r\n可用分区列表。用逗号隔开。\r\n\r\n- filterOnlyUpInstances = true\r\n\r\n是否只拉取UP状态的实例。\r\n\r\n- fetchRegistry=true\r\n\r\n是否拉取注册信息。\r\n\r\n- shouldUnregisterOnShutdown = true\r\n\r\n是否在停止服务的时候向Eureka Server发起Cancel指令。\r\n\r\n- shouldEnforceRegistrationAtInit = false\r\n\r\n是否在初始化过程中注册服务。\r\n\r\n## Eureka Server注册中心端配置\r\n\r\nEureka Server注册中心端的配置是对注册中心的特性配置。Eureka Server的配置全部在org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean里，实际上它是com.netflix.eureka.EurekaServerConfig的实现类，替代了netflix的默认实现。\r\n\r\nEureka Server的配置全部以eureka.server.xxx的格式进行配置。\r\n\r\n**配置列表**\r\n\r\n- enableSelfPreservation=true\r\n\r\n是否开启自我保护\r\n\r\n- renewalPercentThreshold = 0.85\r\n\r\n自我保护续约百分比阀值因子。如果实际续约数小于续约数阀值，则开启自我保护\r\n\r\n- renewalThresholdUpdateIntervalMs = 15 * 60 * 1000\r\n\r\n续约数阀值更新频率。\r\n\r\n- peerEurekaNodesUpdateIntervalMs = 10 * 60 * 1000\r\n\r\nEureka Server节点更新频率。\r\n\r\n- enableReplicatedRequestCompression = false\r\n\r\n是否启用复制请求压缩。\r\n\r\n- waitTimeInMsWhenSyncEmpty=5 * 60 * 1000\r\n\r\n当从其他节点同步实例信息为空时等待的时间。\r\n\r\n- peerNodeConnectTimeoutMs=200\r\n\r\n节点间连接的超时时间。\r\n\r\n- peerNodeReadTimeoutMs=200\r\n\r\n节点间读取信息的超时时间。\r\n\r\n- peerNodeTotalConnections=1000\r\n\r\n节点间连接总数。\r\n\r\n- peerNodeTotalConnectionsPerHost = 500;\r\n\r\n单个节点间连接总数。\r\n\r\n- peerNodeConnectionIdleTimeoutSeconds = 30;\r\n\r\n节点间连接空闲超时时间。\r\n\r\n- retentionTimeInMSInDeltaQueue = 3 * MINUTES;\r\n\r\n增量队列的缓存时间。\r\n\r\n- deltaRetentionTimerIntervalInMs = 30 * 1000;\r\n\r\n清理增量队列中过期的频率。\r\n\r\n- evictionIntervalTimerInMs = 60 * 1000;\r\n\r\n剔除任务频率。\r\n\r\n- responseCacheAutoExpirationInSeconds = 180;\r\n\r\n注册列表缓存超时时间（当注册列表没有变化时）\r\n\r\n- responseCacheUpdateIntervalMs = 30 * 1000;\r\n\r\n注册列表缓存更新频率。\r\n\r\n- useReadOnlyResponseCache = true;\r\n\r\n是否开启注册列表的二级缓存。\r\n\r\n- disableDelta=false。\r\n\r\n是否为client提供增量信息。\r\n\r\n- maxThreadsForStatusReplication = 1;\r\n\r\n状态同步的最大线程数。\r\n\r\n- maxElementsInStatusReplicationPool = 10000;\r\n\r\n状态同步队列的最大容量。\r\n\r\n- syncWhenTimestampDiffers = true;\r\n\r\n当时间差异时是否同步。\r\n\r\n- registrySyncRetries = 0;\r\n\r\n注册信息同步重试次数。\r\n\r\n- registrySyncRetryWaitMs = 30 * 1000;\r\n\r\n注册信息同步重试期间的时间间隔。\r\n\r\n- maxElementsInPeerReplicationPool = 10000;\r\n\r\n节点间同步事件的最大容量。\r\n\r\n- minThreadsForPeerReplication = 5;\r\n\r\n节点间同步的最小线程数。\r\n\r\n- maxThreadsForPeerReplication = 20;\r\n\r\n节点间同步的最大线程数。\r\n\r\n- maxTimeForReplication = 30000;\r\n\r\n节点间同步的最大时间，单位为毫秒。\r\n\r\n- disableDeltaForRemoteRegions = false；\r\n\r\n是否启用远程区域增量。\r\n\r\n- remoteRegionConnectTimeoutMs = 1000;\r\n\r\n远程区域连接超时时间。\r\n\r\n- remoteRegionReadTimeoutMs = 1000;\r\n\r\n远程区域读取超时时间。\r\n\r\n- remoteRegionTotalConnections = 1000;\r\n\r\n远程区域最大连接数\r\n\r\n- remoteRegionTotalConnectionsPerHost = 500;\r\n\r\n远程区域单机连接数\r\n\r\n- remoteRegionConnectionIdleTimeoutSeconds = 30;\r\n\r\n远程区域连接空闲超时时间。\r\n\r\n- remoteRegionRegistryFetchInterval = 30;\r\n\r\n远程区域注册信息拉取频率。\r\n\r\n- remoteRegionFetchThreadPoolSize = 20;\r\n\r\n远程区域注册信息线程数。\r\n\r\n## **Eureka DashBoard注册中心仪表盘配置**\r\n\r\n注册中心仪表盘的配置主要是控制注册中心的可视化展示。以eureka.dashboard.xxx的格式配置。\r\n\r\n- path=\"/\"\r\n\r\n仪表盘访问路径\r\n\r\n- enabled=true\r\n\r\n是否启用仪表盘', '测试', 1677395454138, 1677395454138, 0, 0, 5, 1626607474079477762, 0, 0, 0);
INSERT INTO `question` VALUES (18, 'MongDB写入和读取数据', '```java\r\n/*获取MongoDB的当前时间，时区UTC转GMT*/\r\n    public static Date getMongoDBDate() {\r\n        Calendar calle = Calendar.getInstance();\r\n        calle.setTime(new Date());\r\n        calle.add(Calendar.HOUR_OF_DAY, +8);\r\n        return calle.getTime();\r\n    }\r\n```\r\n\r\n```java\r\nDocument doc = collection.find().first();\r\nDate date = doc.getDate(\"date\");\r\nSimpleDateFormat formattedDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\r\nformattedDate.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\nSystem.out.println(formattedDate.format(date));\r\n```', 'mongodb,java', 1677397064996, 1677397064996, 0, 0, 0, 1626609124953366529, 0, 0, 0);
INSERT INTO `question` VALUES (19, 'MyBatis学习', '# MyBatis学习\r\n\r\n## 框架介绍\r\n\r\n- 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\r\n\r\n## MyBatis 快速入门\r\n\r\n### ORM 介绍\r\n\r\n- ORM(Object Relational Mapping)：**对象关系映射**\r\n\r\n- 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术\r\n\r\n  Object <-->ORM<-->DB     映射规则：数据表->类、表字段->类属性、表数据->对象\r\n\r\n### MyBatis 介绍\r\n\r\n- 原始  JDBC 的操作-查询\r\n\r\n```java\r\npublic class Test {\r\npublic static void main(String[] args) throws Exception{\r\n    Class.forName (\"com.mysq1.jdbc.Driver\");\r\n    String url = \"jdbc:mysql://localhost:3306/db1\";\r\n    String username = \"root\";\r\n    String password = \"root\";\r\n    Connection con = DriverManager.getConnection(url, username, password);\r\n    PreparedStatement pst = con.prepareStatement(\"SELECT * FROM student\");\r\n    ResultSet rs = pst. executeQuery();\r\n    while(rs.next()) {\r\n    Student stu = new Student( );\r\n    stu.setName(rs.getString(columnLabel: \"name\"));\r\n    stu.setAge(rs.getInt(columnLabel: \"age\"));\r\n    stu.setGender(rs.getString( columnLabel: \"gender\"));\r\n    System.out.println(stu);\r\n    }\r\n    rs.close();\r\n    pst.close( );\r\n    con.close( );\r\n    }\r\n}\r\n```\r\n\r\n- 原始  JDBC 的操作-查询\r\n\r\n```java\r\npublic class Test {\r\npublic static void main(String[] args) throws Exception{\r\n    Class.forName (\"com.mysq1.jdbc.Driver\");\r\n    String url = \"jdbc:mysql://localhost:3306/db1\";\r\n    String username = \"root\";\r\n    String password = \"root\";\r\n    Connection con = DriverManager.getConnection(url, username, password);\r\n  \r\n    PreparedStatement pst = con.prepareStatement(\"INSERT INTO student VALUES (?,?,?)\");\r\n    pst.setString(1, stu.getName());\r\n    pst.setInt(2, stu.getAge());\r\n    pst.setString(3, stu.getGender());\r\n    int result = pst.executeUpdate();\r\n    System.out.println(result);\r\n    pst.close( );\r\n    con.close( );\r\n    }\r\n}\r\n```\r\n\r\n- **原始  JDBC 的操作问题分析:**\r\n\r\n  1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\r\n\r\n  2.sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改  java 代码，造成代码不易维护。\r\n\r\n  3.查询操作时，需要手动将结果集中的数据封装到实体对象中。\r\n\r\n  4.增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。\r\n\r\n- **原始  JDBC 的操作问题解决方案:**\r\n\r\n  1.使用数据库连接池初始化连接资源。\r\n\r\n  2.将 sql 语句抽取到配置文件中。\r\n\r\n  3.使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射。\r\n\r\n  \r\n\r\n- MyBatis 是一个优秀的基于  Java 的持久层框架，它内部封装了  JDBC，使开发者只需要关注  SQL 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建执行者等复杂的操作。\r\n\r\n- MyBatis 通过  xml 或注解的方式将要执行的各种 Statement 配置起来，并通过  Java 对象和  Statement 中 SQL 的动态参数进行映射生成最终要执行的 SQL 语句。\r\n\r\n- 最后 MyBatis 框架执行完 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC API 底层访问细节，使我们不用与 JDBC API 打交道，就可以 完成对数据库的持久化操作。\r\n\r\n- MyBatis 官网：http://www.mybatis.org/mybatis-3/\r\n\r\n### MyBatis 入门程序\r\n\r\n1. 数据准备。\r\n\r\n   ```java\r\n   数据库表：student，表字段 id name age\r\n   \r\n   bean包下Student类，private Integer id; private String name; private Integer age;\r\n   \r\n   准备一个测试类：\r\n      		//查询全部\r\n         @Test\r\n         public void selectAll() {\r\n         //1.加载核心配置文件\r\n         //2.获取SqLSession工厂对象\r\n         //3.通过SqLSession工厂对象获取SqISession对象\r\n         //4.执行映射配置文件中的sqL语句，并接收结果\r\n         //5.处理结果\r\n         //6.释放资源\r\n         }\r\n   ```\r\n\r\n   \r\n\r\n2. 导入 mybatis-3.5.3.jar、mysql-connector-java-5.1.37-bin.jar包。\r\n\r\n3. 在  src 下创建映射配置文件-StudentMapper.xml。\r\n\r\n4. 在  src 下创建核心配置文件-MyBatisConfig.xml。\r\n\r\n5. 编写测试类完成相关  API 的使用。\r\n\r\n6. 运行测试查看结果。\r\n\r\n## MyBatis 相关 API\r\n\r\n### Resources\r\n\r\n- org.apache.ibatis.io.Resources：加载资源的工具类。\r\n\r\n- 核心方法\r\n\r\n  | 返回值      | 方法名                               | 说明                                 |\r\n  | ----------- | ------------------------------------ | ------------------------------------ |\r\n  | InputStream | getResourceAsStream(String fileName) | 通过类加载器返回指定资源的字节输入流 |\r\n\r\n### SqlSessionFactoryBuilder\r\n\r\n- org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类。\r\n\r\n- 核心方法\r\n\r\n  | 返回值            | 方法名                | 说明                                         |\r\n  | ----------------- | --------------------- | -------------------------------------------- |\r\n  | SqlSessionFactory | build(InputStream is) | 通过指定资源字节输入流获取SqlSession工厂对象 |\r\n\r\n  \r\n\r\n### SqlSessionFactory\r\n\r\n- org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\r\n\r\n- 核心方法\r\n\r\n  | 返回值     | 方法名                          | 说明                                                         |\r\n  | ---------- | ------------------------------- | ------------------------------------------------------------ |\r\n  | SqlSession | openSession()                   | 获取SqlSession构建者对象，并开启手动提交事务                 |\r\n  | SqlSession | openSession(boolean autoCommit) | 获取SqlSession构建者对象，如果参数为true，则开启自动提交事务 |\r\n\r\n### SqlSession\r\n\r\n- org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\r\n\r\n| 返回值  | 方法名                                       | 说明                           |\r\n| ------- | -------------------------------------------- | ------------------------------ |\r\n| List<E> | selectList(String statement,Object paramter) | 执行查询语句，返回List集合     |\r\n| T       | selectOne(String statement,Object paramter)  | 执行查询语句，返回一个结果对象 |\r\n| int     | insert(String statement,Object paramter)     | 执行新增语句，返回影响行数     |\r\n| int     | update(String statement,Object paramter)     | 执行修改语句，返回影响行数     |\r\n| int     | delete(String statement,Object paramter)     | 执行删除语句，返回影响行数     |\r\n| void    | commit()                                     | 提交事务                       |\r\n| void    | rollback()                                   | 回滚事务                       |\r\n| T       | getMapper(Class<T> cls)                      | 获取指定接口的代理实现类对象   |\r\n| void    | close()                                      | 释放资源                       |\r\n\r\n\r\n\r\n## MyBatis 映射配置文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!--MyBatis的DTD约束-->\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n\r\n<!--\r\n    mapper：核心根标签\r\n    namespace属性：名称空间\r\n-->\r\n<mapper namespace=\"StudentMapper\">\r\n    <!--\r\n        select：查询功能的标签、<insert>：新增功能标签、<update>：修改功能标签、<delete>：删除功能标签\r\n        id属性：唯一标识\r\n        resultType属性：指定结果映射对象类型\r\n        parameterType属性：指定参数映射对象类型\r\n        SQL 获取参数:\r\n        #{属性名}\r\n    -->\r\n    <select id=\"selectAll\" resultType=\"student\">\r\n        SELECT * FROM student\r\n    </select>\r\n\r\n    <select id=\"selectById\" resultType=\"student\" parameterType=\"int\">\r\n        SELECT * FROM student WHERE id = #{id}\r\n    </select>\r\n\r\n    <insert id=\"insert\" parameterType=\"student\">\r\n        INSERT INTO student VALUES (#{id},#{name},#{age})\r\n    </insert>\r\n\r\n    <update id=\"update\" parameterType=\"student\">\r\n        UPDATE student SET name = #{name},age = #{age} WHERE id = #{id}\r\n    </update>\r\n\r\n    <delete id=\"delete\" parameterType=\"int\">\r\n        DELETE FROM student WHERE id = #{id}\r\n    </delete>\r\n</mapper>\r\n```\r\n\r\n## MyBatis 核心配置文件\r\n\r\njdbc.properties\r\n\r\n```mysql\r\ndriver=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost/db1\r\nusername=root\r\npassword=root\r\n```\r\n\r\nMyBatisConfig.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!--MyBatis的DTD约束-->\r\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n\r\n<!--configuration 核心根标签-->\r\n<configuration>\r\n    <!--引入数据库连接的配置文件-->\r\n    <properties resource=\"jdbc.properties\"/>\r\n    <!--配置LOG4J-->\r\n    <settings>\r\n        <setting name=\"logImpl\" value=\"log4j\"/>\r\n    </settings>\r\n    <!--起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"plus.axz.bean.Student\" alias=\"student\"/>\r\n        <!--<package name=\"plus.axz.bean\"/>-->\r\n    </typeAliases>\r\n    <!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个-->\r\n    <environments default=\"mysql\">\r\n        <!--environment配置数据库环境  id属性唯一标识-->\r\n        <environment id=\"mysql\">\r\n            <!-- transactionManager事务管理。  type属性，采用JDBC默认的事务-->\r\n            <transactionManager type=\"JDBC\"></transactionManager>\r\n            <!-- dataSource数据源信息   type属性 连接池-->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- property获取数据库连接的配置信息 -->\r\n                <property name=\"driver\" value=\"${driver}\" />\r\n                <property name=\"url\" value=\"${url}\" />\r\n                <property name=\"username\" value=\"${username}\" />\r\n                <property name=\"password\" value=\"${password}\" />\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n    <!-- mappers引入映射配置文件 -->\r\n    <mappers>\r\n        <!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 -->\r\n        <mapper resource=\"StudentMapper.xml\"/>\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n数据库连接配置文件引入\r\n\r\n- <properties>：引入数据库连接配置文件标签。\r\n- 属性\r\n  resource：数据库连接配置文件路径\r\n- 获取数据库连接参数 \r\n  ${键名}\r\n\r\n起别名\r\n\r\n- <typeAliases>：为全类名起别名的父标签。\r\n- <typeAlias>：为全类名起别名的子标签。\r\n- 属性\r\n  type：指定全类名 \r\n  alias：指定别名\r\n- <package>：为指定包下所有类起别名的子标签。(别名就是类名)\r\n\r\n```java\r\n    <!--起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"plus.axz.bean.Student\" alias=\"student\"/>\r\n        <!--<package name=\"p.bean\"/>-->\r\n    </typeAliase\r\n```\r\n\r\n| 别名    | 数据类型          |\r\n| ------- | ----------------- |\r\n| string  | java.lang.String  |\r\n| long    | java.lang.Long    |\r\n| int     | java.lang.Integer |\r\n| double  | java.lang.Double  |\r\n| boolean | java.lang.Boolean |\r\n\r\n### 核心配置文件小结\r\n\r\n- 核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\r\n- <configuration>：核心根标签。\r\n- <properties>：引入数据库连接信息配置文件标签。\r\n- <typeAliases>：起别名标签。\r\n- <environments>：配置数据库环境标签。\r\n- <environment>：配置数据库信息标签。\r\n- <transactionManager>：事务管理标签。\r\n- <dataSource>：数据源标签。\r\n- <property>：数据库连接信息标签。\r\n- <mappers>：引入映射配置文件标签。\r\n\r\n## MyBatis 传统方式实现 Dao 层-进阶\r\n\r\n### Dao 层传统实现方式\r\n\r\n- 分层思想：控制层(controller)、业务层(service)、持久层(dao)。\r\n- 调用流程\r\n\r\n控制层->业务层->持久层->DB\r\n\r\n### LOG4J\r\n\r\n- 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的  SQL 语句、参数、结果等信息，可以借助  LOG4J 的功能来实现执行信息的输出。\r\n- 使用步骤\r\n\r\n1. 导入log4j-1.2.17.jar包。\r\n\r\n2. 修改核心配置文件 MyBatisConfig.xml 添加：\r\n\r\n   ```xml\r\n   <!--集成L0G4J日志信息-->\r\n   <settings>\r\n   		<setting name=\"logImpl\" value= \"log4j\"/>\r\n   </settings>\r\n   ```\r\n\r\n3. 在  src 下编写  LOG4J 配置文件。\r\n\r\n```xml\r\n# 输出等级  ERROR WARN INFO DEBUG   # stdout把信息输出到控制台上\r\nlog4j.rootLogger=DEBUG, stdout\r\n# 输出格式\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n\r\n\r\n## MyBatis 接口代理方式实现 Dao 层\r\n\r\n### 接口代理方式-实现规则\r\n\r\n- 传统方式实现 Dao 层，我们既要写接口，还要写实现类。而 MyBatis 框架可以帮助我们省略编写 Dao 层接口实现类的步骤。程序员只需要编写接口，由 MyBatis 框架根据接口的定义来创建该接口的动态代理对象。\r\n\r\n- **实现规则**\r\n\r\n  ​	**映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。**\r\n\r\n  ​	**映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。**\r\n\r\n### 接口代理方式-代码实现\r\n\r\n1.  删除 mapper 层接口的实现类。\r\n2.  修改映射配置文件。\r\n3.  修改 service 层接口的实现类，采用接口代理方式实现功能。\r\n\r\n### 接口代理方式-源码分析\r\n\r\n- 分析动态代理对象如何生成的？\r\n  通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。\r\n- 分析方法是如何执行的？\r\n  动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的SqlSession 方式来执行增删改查。\r\n\r\n### 接口代理方式小结\r\n\r\n- 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。\r\n\r\n- 实现规则\r\n\r\n  ​	映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。\r\n\r\n  ​	映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。\r\n\r\n- 获取动态代理对象\r\n  SqlSession 功能类中的 getMapper() 方法。\r\n\r\n## MyBatis 映射配置文件 – 动态 SQL\r\n\r\nMyBatis 映射配置文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 就是 \r\n动态变化的，此时在前面学习的 SQL 就不能满足要求了。\r\n\r\n- 多条件查询\r\n\r\n​		id:3 name:萧萧 age:25\r\n\r\n​		SELECT * FROM student WHERE id = ? AND name = ? AND age = ?\r\n\r\n​		id:3 name:萧萧\r\n\r\n​		SELECT * FROM student WHERE id = ? AND name = ?\r\n\r\n- 动态 SQL 标签\r\n  <if>：条件判断标签。 \r\n  <foreach>：循环遍历标签。\r\n\r\n### if标签\r\n\r\n- <where>：条件标签。如果有动态条件，则使用该标签代替 where 关键字。\r\n\r\n- <if>：条件判断标签。\r\n\r\n  ```sql\r\n  <if test=\"条件判断\"> \r\n  查询条件拼接\r\n  </if>\r\n  ```\r\n\r\n### foreach标签\r\n\r\n- <foreach>：循环遍历标签。适用于多个参数或者的关系。\r\n\r\n  ```sql\r\n  <foreach collection=\"\" open=\"\" close=\"\"item=\"\"separator=\"\"> \r\n  		获取参数\r\n  </foreach>\r\n  ```\r\n\r\n- 属性\r\n\r\n  > collection：参数容器类型，(list-集合，array-数组)。 \r\n  > open：开始的 SQL 语句。\r\n  > close：结束的 SQL 语句。 \r\n  > item：参数变量名。 \r\n  > separator：分隔符。\r\n\r\n### SQL 片段抽取\r\n\r\n- 我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。\r\n\r\n  ```sql\r\n  <sql>：抽取 SQL 语句标签。\r\n  <sql id=\"片段唯一标识\">抽取的 SQL 语句</sql>\r\n  \r\n  <include>：引入 SQL 片段标签。\r\n  <include refid=\"片段唯一标识\"/>\r\n  ```\r\n\r\n### 动态  SQL 小结\r\n\r\n动态 SQL 指的就是 SQL 语句可以根据条件或者参数的不同进行动态的变化。\r\n\r\n> <where>：条件标签。\r\n> <if>：条件判断的标签。\r\n> <foreach>：循环遍历的标签。\r\n> <sql>：抽取 SQL 片段的标签。\r\n> <include>：引入 SQL 片段的标签。\r\n\r\n\r\n\r\n## MyBatis 核心配置文件 – 分页插件\r\n\r\n分页插件介绍：\r\n\r\n- 分页可以将很多条结果进行分页显示。\r\n\r\n- 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。\r\n\r\n- 需要明确当前是第几页，这一页中显示多少条结果。\r\n- 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 \r\n  功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 \r\n  成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。\r\n- PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。\r\n\r\n\r\n\r\n### 分页插件实现步骤\r\n\r\n1.  导入 jar 包。\r\n2.  在核心配置文件中集成分页助手插件。\r\n3.  在测试类中使用分页助手相关 API 实现分页功能。\r\n\r\n\r\n\r\n### 分页插件相关参数\r\n\r\n- PageInfo：封装分页相关参数的功能类。\r\n\r\n- 核心方法\r\n\r\n| 返回值  | 方法名          | 说明               |\r\n| ------- | --------------- | ------------------ |\r\n| long    | getTotal()      | 获取总条数         |\r\n| int     | getPages()      | 获取总页数         |\r\n| int     | getPageNum()    | 获取当前页         |\r\n| int     | getPageSize()   | 获取每页显示条数   |\r\n| int     | getPrePage()    | 获取上一页         |\r\n| int     | getNextPage()   | 获取下一页         |\r\n| boolean | isIsFirstPage() | 获取是否是第一页   |\r\n| boolean | isIsLastPage()  | 获取是否是最后一页 |\r\n\r\n### 分页插件小结\r\n\r\n- 分页：可以将很多条结果进行分页显示。\r\n\r\n- 分页插件 jar 包：pagehelper-5.1.10.jar        jsqlparser-3.1.jar\r\n\r\n- <plugins>：集成插件标签。\r\n\r\n- 分页助手相关 API\r\n\r\n  > PageHelper：分页助手功能类。 \r\n  > 		startPage()：设置分页参数\r\n  > PageInfo：分页相关参数功能类。\r\n  > 		getTotal()：获取总条数\r\n  > 		getPages()：获取总页数\r\n  > 		getPageNum()：获取当前页\r\n  > 		getPageSize()：获取每页显示条数\r\n  > 		getPrePage()：获取上一页\r\n  > 		getNextPage()：获取下一页 \r\n  > 		isIsFirstPage()：获取是否是第一页 \r\n  > 		isIsLastPage()：获取是否是最后一页\r\n\r\n## 多表模型\r\n\r\n- 多表模型分类\r\n  	一对一：在任意一方建立外键，关联对方的主键。 \r\n  	一对多：在多的一方建立外键，关联一的一方的主键。\r\n  	多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。\r\n\r\n一对一\r\n		一对一模型：人和身份证，一个人只有一个身份证。\r\n		环境准备\r\n\r\n```sql\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <association>：配置被包含对象的映射关系标签。 \r\nproperty 属性：被包含对象的变量名 \r\njavaType 属性：被包含对象的数据类型\r\n```\r\n\r\n一对多\r\n	一对多模型：班级和学生，一个班级可以有多个学生。\r\n	环境准备。\r\n\r\n```sql\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n多对多\r\n	多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。\r\n	环境准备。\r\n\r\n```\r\n<resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称\r\nproperty 属性： 实体对象变量名称\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n### 多表操作小结\r\n\r\n```\r\n多表模型分类：一对一、一对多、多对多。\r\n    <resultMap>：配置字段和对象属性的映射关系标签。 \r\nid 属性：唯一标识\r\ntype 属性：实体对象类型\r\n    <id>：配置主键映射关系标签。\r\n    <result>：配置非主键映射关系标签。 \r\ncolumn 属性：表中字段名称 \r\nproperty 属性： 实体对象变量名称\r\n    <association>：配置被包含对象的映射关系标签。 \r\nproperty 属性：被包含对象的变量名 \r\njavaType 属性：被包含对象的数据类型\r\n    <collection>：配置被包含集合对象的映射关系标签。 \r\nproperty 属性：被包含集合对象的变量名 \r\nofType 属性：集合中保存的对象数据类型\r\n```\r\n\r\n## MyBatis 注解开发\r\n\r\n常用注解介绍\r\n\r\n- 我们除了可以使用映射配置文件来操作以外，还可以使用注解形式来操作。\r\n  - 常用注解\r\n    @Select(“查询的 SQL 语句”)：执行查询操作注解 \r\n    @Insert(“新增的 SQL 语句”)：执行新增操作注解 \r\n    @Update(“修改的 SQL 语句”)：执行修改操作注解 \r\n    @Delete(“删除的 SQL 语句”)：执行删除操作注解\r\n\r\n注解实现查询操作\r\n\r\n- 创建接口和查询方法\r\n\r\n- 在核心配置文件中配置映射关系\r\n\r\n  ```\r\n  <mappers>\r\n  	<package name =\"接口所在包\"/>\r\n  </mappers>\r\n  ```\r\n\r\n  \r\n\r\n- 编写测试类\r\n\r\n注解实现修改操作\r\n\r\n- 创建修改方法\r\n\r\n- 编写测试类\r\n\r\n注解实现删除操作\r\n\r\n- 创建删除方法\r\n- 编写测试类\r\n\r\n\r\n\r\n\r\n\r\n## MyBatis 注解实现多表操作\r\n\r\n一对一\r\n\r\n```sql\r\n环境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\none 属性：一对一查询固定属性\r\n    @One：一对一查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n一对多\r\n\r\n```sql\r\n境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\nmany 属性：一对多查询固定属性\r\n    @Many：一对多查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n多对多\r\n\r\n```sql\r\n环境准备\r\n    @Results：封装映射关系的父注解。 \r\nResult[] value()：定义了 Result 数组\r\n    @Result：封装映射关系的子注解。 \r\ncolumn 属性：查询出的表中字段名称 \r\nproperty 属性：实体对象中的属性名称 \r\njavaType 属性：被包含对象的数据类型 \r\nmany 属性：一对多查询固定属性\r\n    @Many：一对多查询的注解。\r\nselect 属性：指定调用某个接口中的方法\r\n```\r\n\r\n### 注解多表操作小结\r\n\r\n- @Results：封装映射关系的父注解。 \r\n  	Result[] value()：定义了 Result 数组\r\n\r\n- @Result：封装映射关系的子注解。 \r\n\r\n  ​	column 属性：查询出的表中字段名称 \r\n  ​	property 属性：实体对象中的属性名称 \r\n  ​	javaType 属性：被包含对象的数据类型 \r\n  ​	one 属性：一对一查询固定属性 \r\n  ​	many 属性：一对多查询固定属性\r\n\r\n- @One：一对一查询的注解。\r\n\r\n  ​	select 属性：指定调用某个接口中的方法\r\n\r\n- @Many：一对多查询的注解。\r\n\r\n  ​	select 属性：指定调用某个接口中的方法\r\n\r\n### SQL 构建对象介绍\r\n\r\n我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。\r\nMyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句。\r\n\r\n| 方法名                              | 说明                         |\r\n| ----------------------------------- | ---------------------------- |\r\n| SELECT(String…column)               | 根据字段拼接查询语句         |\r\n| FROM(String…table)                  | 根据表名拼接语句             |\r\n| WHERE(String…condition)             | 根据条件拼接语句             |\r\n| INSERT_INTO(String table)           | 根据表名拼接新增语句         |\r\n| VALUES(String column,String values) | 根据字段和值拼接插入数据语句 |\r\n| UPDATE(String table)                | 根据表名拼接修改语句         |\r\n| DELETE_FROM(String table)           | 根据表名拼接删除语句         |\r\n\r\n### MyBatis 构建 SQL 语句\r\n\r\n#### 查询操作\r\n\r\n- 定义功能类并提供获取查询的 SQL 语句的方法。\r\n\r\n- @SelectProvider：生成查询用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n#### 新增操作\r\n\r\n- 定义功能类并提供获取新增的 SQL 语句的方法。\r\n- @InsertProvider：生成新增用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n\r\n\r\n#### 修改操作\r\n\r\n- 定义功能类并提供获取修改的 SQL 语句的方法。\r\n\r\n- @UpdateProvider：生成修改用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n#### 删除操作\r\n\r\n- 定义功能类并提供获取删除的 SQL 语句的方法。\r\n- @DeleteProvider：生成删除用的 SQL 语句注解。 \r\n  type 属性：生成 SQL 语句功能类对象 \r\n  method 属性：指定调用方法\r\n\r\n\r\n\r\n### 构建SQL 语句小结\r\n\r\n```sql\r\norg.apache.ibatis.jdbc.SQL：构建 SQL 语句的功能类。通过一些方法来代替 SQL 语句的关键字。 \r\n    SELECT()\r\n    FROM() \r\n    WHERE() \r\n    INSERT_INTO() \r\n    VALUES() \r\n    UPDATE() \r\n    DELETE_FROM()\r\n@SelectProvider：生成查询用的 SQL 语句注解。\r\n@InsertProvider：生成新增用的 SQL 语句注解。\r\n@UpdateProvider：生成修改用的 SQL 语句注解。\r\n@DeleteProvider：生成删除用的 SQL 语句注解。 \r\n    type 属性：生成 SQL 语句功能类对象 \r\n    method 属性：指定调用方法\r\n```', 'mybatis,java', 1677397208079, 1677397208079, 4, 0, 17, 1626609807895044097, 1, 0, 0);
INSERT INTO `question` VALUES (20, 'SpringBoot集成Swagger和knife4j', '# SpringBoot集成Swagger\r\n\r\n(1)简介\r\n\r\nSwagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(https://swagger.io/)。 它的主要作用是：\r\n\r\n1. 使得前后端分离开发更加方便，有利于团队协作\r\n2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担\r\n3. 功能测试 \r\n\r\nSpring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。\r\n\r\n(2)SpringBoot集成Swagger\r\n\r\n- 引入依赖,在model模块中引入该依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>io.springfox</groupId>\r\n    <artifactId>springfox-swagger2</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.springfox</groupId>\r\n    <artifactId>springfox-swagger-ui</artifactId>\r\n</dependency>\r\n```\r\n\r\n只需要在common中进行配置即可，因为其他微服务工程都直接或间接依赖即可。\r\n\r\n- 在admin工程的config包中添加一个配置类\r\n\r\n```java\r\npackage com.axz.admin.config;\r\n\r\nimport com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;\r\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Import;\r\nimport springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;\r\nimport springfox.documentation.builders.ApiInfoBuilder;\r\nimport springfox.documentation.builders.PathSelectors;\r\nimport springfox.documentation.builders.RequestHandlerSelectors;\r\nimport springfox.documentation.service.ApiInfo;\r\nimport springfox.documentation.service.Contact;\r\nimport springfox.documentation.spi.DocumentationType;\r\nimport springfox.documentation.spring.web.plugins.Docket;\r\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\r\n\r\n@Configuration\r\n@EnableSwagger2\r\n@EnableKnife4j\r\n@Import(BeanValidatorPluginsConfiguration.class)\r\npublic class Swagger2Configuration {\r\n\r\n    @Bean(value = \"defaultApi2\")\r\n    public Docket defaultApi2() {\r\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                //分组名称\r\n                .groupName(\"xiao-blog接口1.0\")\r\n                .select()\r\n                //这里指定Controller扫描包路径\r\n                .apis(RequestHandlerSelectors.basePackage(\"plus.axz\"))\r\n                .paths(PathSelectors.any())\r\n                .build();\r\n        return docket;\r\n    }\r\n    private ApiInfo apiInfo() {\r\n        return new ApiInfoBuilder()\r\n                .title(\"xiao-博客API文档\")\r\n                .contact(new Contact(\"xiaoxiang\",\"http://0916.pro\",\"1056965430@qq.com\"))\r\n                .license(\"xiaoxiang\")\r\n                .licenseUrl(\"http://0916.pro\")\r\n                .description(\"xiao-博客API文档\")\r\n                .version(\"1.0\")\r\n                .build();\r\n    }\r\n}\r\n```\r\n\r\n（3）Swagger常用注解\r\n\r\n在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：\r\n\r\n@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数的描述信息 \r\n\r\n@ApiModel：用对象来接收参数 \r\n\r\n@ApiModelProperty：用对象接收参数时，描述对象的一个字段 \r\n\r\n@ApiResponse：HTTP响应其中1个描述 \r\n\r\n@ApiResponses：HTTP响应整体描述 \r\n\r\n@ApiIgnore：使用该注解忽略这个API \r\n\r\n@ApiError ：发生错误返回的信息 \r\n\r\n@ApiImplicitParam：一个请求参数 \r\n\r\n@ApiImplicitParams：多个请求参数的描述信息\r\n\r\n@ApiImplicitParam属性：\r\n\r\n| 属性         | 取值   | 作用                                          |\r\n| ------------ | ------ | --------------------------------------------- |\r\n| paramType    |        | 查询参数类型                                  |\r\n|              | path   | 以地址的形式提交数据                          |\r\n|              | query  | 直接跟参数完成自动映射赋值                    |\r\n|              | body   | 以流的形式提交 仅支持POST                     |\r\n|              | header | 参数在request headers 里边提交                |\r\n|              | form   | 以form表单的形式提交 仅支持POST               |\r\n| dataType     |        | 参数的数据类型 只作为标志说明，并没有实际验证 |\r\n|              | Long   |                                               |\r\n|              | String |                                               |\r\n| name         |        | 接收参数名                                    |\r\n| value        |        | 接收参数的意义描述                            |\r\n| required     |        | 参数是否必填                                  |\r\n|              | true   | 必填                                          |\r\n|              | false  | 非必填                                        |\r\n| defaultValue |        | 默认值                                        |\r\n\r\n在TagControllerApi中添加Swagger注解，代码如下所示：\r\n\r\n```java\r\npackage com.axz.apis.admin;\r\n\r\nimport com.axz.model.admin.dtos.TagDto;\r\nimport com.axz.model.admin.pojos.Tag;\r\nimport com.axz.model.common.dtos.ResponseResult;\r\nimport io.swagger.annotations.Api;\r\nimport io.swagger.annotations.ApiOperation;\r\n\r\n@Api(value = \"标签管理\", tags = \"tag\", description = \"标签管理API\")\r\npublic interface TagControllerApi {\r\n\r\n    /**\r\n     * 根据名称分页查询标签列表\r\n     * @param dto\r\n     * @return\r\n     */\r\n    @ApiOperation(\"标签分页列表查询\")\r\n    public ResponseResult findByNameAndPage(TagDto dto);\r\n\r\n    /**\r\n     * 新增\r\n     * @param tag\r\n     * @return\r\n     */\r\n    @ApiOperation(\"新增标签\")\r\n    public ResponseResult save(Tag tag);\r\n\r\n    /**\r\n     * 修改\r\n     * @param tag\r\n     * @return\r\n     */\r\n    @ApiOperation(\"修改标签\")\r\n    public ResponseResult update(Tag tag);\r\n\r\n    /**\r\n     * 删除\r\n     * @param id\r\n     * @return\r\n     */\r\n    @ApiOperation(\"删除标签\")\r\n    public ResponseResult deleteById(Integer id);\r\n}\r\n```\r\n\r\nTagDto\r\n\r\n```Java\r\npackage com.axz.model.admin.dtos;\r\n\r\nimport com.axz.model.common.dtos.PageRequestDto;\r\nimport io.swagger.annotations.ApiModelProperty;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Data/*重写get、set方法*/\r\n@Builder\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class TagDto extends PageRequestDto {\r\n    /*接收三个参数---频道名称-当前页-每页显示条数*/\r\n    /*通过继承PageRequestDto，接收当前页-每页显示条数*/\r\n    /**\r\n     * 标签名称\r\n     */\r\n    @ApiModelProperty(\"标签名称\")/*描述当前接收参数的信息，，比如该name就是指标签名称*/\r\n    private String tag_name;\r\n}\r\n```\r\n\r\nPageRequestDto\r\n\r\n```Java\r\npackage com.axz.model.common.dtos;\r\n\r\nimport io.swagger.annotations.ApiModelProperty;\r\nimport lombok.Data;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Data\r\n@Slf4j\r\npublic class PageRequestDto {\r\n\r\n    @ApiModelProperty(value=\"每页显示条数\",required = true)/*required 参数必须要传*/\r\n    protected Integer size;\r\n    @ApiModelProperty(value=\"当前页\",required = true)\r\n    protected Integer page;\r\n\r\n    public void checkParam() {\r\n        if (this.page == null || this.page < 0) {/*等于null或者小于0,赋予默认值第1页*/\r\n            setPage(1);\r\n        }\r\n        if (this.size == null || this.size < 0 || this.size > 100) {/*等于null或者小于0或大于100,赋予默认值10条数据*/\r\n            setSize(10);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n启动admin微服务，访问地址：http://localhost:端口号/swagger-ui.html\r\n\r\n\r\n\r\n# SpringBoot集成knife4j\r\n\r\n(1)简介\r\n\r\nknife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!\r\n\r\ngitee地址：https://gitee.com/xiaoym/knife4j\r\n\r\n官方文档：https://doc.xiaominfo.com/\r\n\r\n效果演示：http://knife4j.xiaominfo.com/doc.html\r\n\r\n(2)核心功能\r\n\r\n该UI增强包主要包括两大核心功能：文档说明 和 在线调试\r\n\r\n- 文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。\r\n- 在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。\r\n- 个性化配置：通过个性化ui配置项，可自定义UI的相关显示信息\r\n- 离线文档：根据标准规范，生成的在线markdown离线文档，开发者可以进行拷贝生成markdown接口文档，通过其他第三方markdown转换工具转换成html或pdf，这样也可以放弃swagger2markdown组件\r\n- 接口排序：自1.8.5后，ui支持了接口排序功能，例如一个注册功能主要包含了多个步骤,可以根据swagger-bootstrap-ui提供的接口排序规则实现接口的排序，step化接口操作，方便其他开发者进行接口对接\r\n\r\n(3)快速集成\r\n\r\n- 在common模块中的`pom.xml`文件中引入`knife4j`的依赖,如下：\r\n\r\n```\r\n<dependency>\r\n     <groupId>com.github.xiaoymin</groupId>\r\n     <artifactId>knife4j-spring-boot-starter</artifactId>\r\n</dependency>\r\n```\r\n\r\n- 创建Swagger配置文件\r\n\r\n在common模块中新建配置类\r\n\r\n新建Swagger的配置文件`SwaggerConfiguration.java`文件,创建springfox提供的Docket分组对象,代码如下：\r\n\r\n```java\r\npackage com.axz.common.knife4j;\r\n\r\nimport com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Import;\r\nimport springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;\r\nimport springfox.documentation.builders.ApiInfoBuilder;\r\nimport springfox.documentation.builders.PathSelectors;\r\nimport springfox.documentation.builders.RequestHandlerSelectors;\r\nimport springfox.documentation.service.ApiInfo;\r\nimport springfox.documentation.spi.DocumentationType;\r\nimport springfox.documentation.spring.web.plugins.Docket;\r\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\r\n\r\n@Configuration\r\n@EnableSwagger2\r\n@EnableKnife4j\r\n@Import(BeanValidatorPluginsConfiguration.class)\r\npublic class Swagger2Configuration {\r\n\r\n    @Bean(value = \"defaultApi2\")\r\n    public Docket defaultApi2() {\r\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                //分组名称\r\n                .groupName(\"1.0\")\r\n                .select()\r\n                //这里指定Controller扫描包路径\r\n                .apis(RequestHandlerSelectors.basePackage(\"com.axz\"))\r\n                .paths(PathSelectors.any())\r\n                .build();\r\n        return docket;\r\n    }\r\n    private ApiInfo apiInfo() {\r\n        return new ApiInfoBuilder()\r\n                .title(\"axz-博客API文档\")\r\n                .description(\"axz-博客API文档\")\r\n                .version(\"1.0\")\r\n                .build();\r\n    }\r\n}\r\n```\r\n\r\n以上有两个注解需要特别说明，如下表：\r\n\r\n| 注解            | 说明                                                         |\r\n| --------------- | ------------------------------------------------------------ |\r\n| @EnableSwagger2 | 该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加 |\r\n| @EnableKnife4j  | 该注解是`knife4j`提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加 |\r\n\r\n- 访问\r\n\r\n在admin中开启配置\r\n\r\n在config包下新建类KnifeConfig\r\n\r\n```java\r\npackage com.axz.admin.config;\r\n\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@ComponentScan(\"com.axz.common.knife4j\")\r\npublic class KnifeConfig {\r\n}\r\n```\r\n\r\n- 访问\r\n\r\n在浏览器输入地址：`http://localhost:端口号/doc.html`', 'springboot', 1677399428746, 1677399428746, 2, 0, 2, 1626531712840261634, 0, 0, 0);
INSERT INTO `question` VALUES (21, '日志配置', '![下载附件](http://xiao-xiao.oss-cn-beijing.aliyuncs.com/6069e9a9-d5f5-4a7e-9448-c16378956e35.png?Expires=1708935624&OSSAccessKeyId=LTAI5tLUsBPzeq8nF3a4HNWx&Signature=pISpW6V7EuWM3jWtR8TQduInrgQ%3D)\r\n\r\nSpringboot默认集成日志信息logback.xml,在log4j基础上做了增强\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<configuration>\r\n    <!--定义日志文件的存储地址,使用绝对路径-->\r\n    <property name=\"LOG_HOME\" value=\"F:/xiao-logs\"/>\r\n\r\n    <!-- Console 输出设置 -->\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <encoder>\r\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n            <charset>utf8</charset>\r\n        </encoder>\r\n    </appender>\r\n\r\n    <!-- 按照每天生成日志文件 -->\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\r\n            <!--日志文件输出的文件名-->\r\n            <fileNamePattern>${LOG_HOME}/axz-blog.%d{yyyy-MM-dd}.log</fileNamePattern>\r\n           <!--日志文件保留天数-->\r\n            <MaxHistory>30</MaxHistory>\r\n        </rollingPolicy>\r\n      <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->\r\n        <encoder>\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n        </encoder>\r\n       <!--日志文件最大的大小-->\r\n        <triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\">\r\n            <MaxFileSize>10MB</MaxFileSize>\r\n        </triggeringPolicy>\r\n    </appender>\r\n\r\n    <!-- 异步输出 -->\r\n    <appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\">\r\n        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->\r\n        <discardingThreshold>0</discardingThreshold>\r\n        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->\r\n        <queueSize>512</queueSize>\r\n        <!-- 添加附加的appender,最多只能添加一个 -->\r\n        <appender-ref ref=\"FILE\"/>\r\n    </appender>\r\n\r\n\r\n    <logger name=\"org.apache.ibatis.cache.decorators.LoggingCache\" level=\"DEBUG\" additivity=\"false\">\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n    </logger>\r\n  <!-- 日志级别排序为： TRACE < DEBUG < INFO < WARN < ERROR -->\r\n    <logger name=\"org.springframework.boot\" level=\"debug\"/>\r\n <!--指定info--> \r\n    <root level=\"info\">\r\n        <!--<appender-ref ref=\"ASYNC\"/>-->\r\n        <appender-ref ref=\"FILE\"/>\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<configuration>\r\n    &lt;!&ndash;定义日志文件的存储地址,使用绝对路径&ndash;&gt;\r\n&lt;!&ndash;    <property name=\"LOG_HOME\" value=\"F:/xiao/xiao-admin-logs\"/>&ndash;&gt;\r\n    <property name=\"LOG_HOME\" value=\"${LOG_PATH:-.}\"/>&lt;!&ndash;yml指定&ndash;&gt;\r\n    <property name=\"LOG_HOME\" value=\"${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}\"/>\r\n\r\n    &lt;!&ndash; Console控制台 输出设置 &ndash;&gt;\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <encoder>\r\n            &lt;!&ndash;格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符&ndash;&gt;\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n            <charset>utf8</charset>\r\n        </encoder>\r\n    </appender>\r\n\r\n    &lt;!&ndash; 按照每天生成日志文件 &ndash;&gt;\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\r\n            &lt;!&ndash;日志文件输出的文件名&ndash;&gt;\r\n            <fileNamePattern>${LOG_HOME}/axz-blog.%d{yyyy-MM-dd}.log</fileNamePattern>\r\n            &lt;!&ndash;日志文件保留天数&ndash;&gt;\r\n            <MaxHistory>30</MaxHistory>\r\n        </rollingPolicy>\r\n        &lt;!&ndash; 1格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符&ndash;&gt;\r\n        <encoder>\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n        </encoder>\r\n        &lt;!&ndash;日志文件最大的大小&ndash;&gt;\r\n        <triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\">\r\n            <MaxFileSize>10MB</MaxFileSize>\r\n        </triggeringPolicy>\r\n    </appender>\r\n\r\n    &lt;!&ndash; 异步输出 &ndash;&gt;\r\n    <appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\">\r\n        &lt;!&ndash; 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 &ndash;&gt;\r\n        <discardingThreshold>0</discardingThreshold>\r\n        &lt;!&ndash; 更改默认的队列的深度,该值会影响性能.默认值为256 &ndash;&gt;\r\n        <queueSize>512</queueSize>\r\n        &lt;!&ndash; 添加附加的appender,最多只能添加一个 &ndash;&gt;\r\n        <appender-ref ref=\"FILE\"/>\r\n    </appender>\r\n\r\n\r\n    <logger name=\"org.apache.ibatis.cache.decorators.LoggingCache\" level=\"DEBUG\" additivity=\"false\">\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n    </logger>\r\n    &lt;!&ndash; 日志级别排序为： TRACE < DEBUG < INFO < WARN < ERROR &ndash;&gt;\r\n    &lt;!&ndash;日志级别&ndash;&gt;\r\n    <logger name=\"org.springframework.boot\" level=\"debug\"/>\r\n    &lt;!&ndash;指定INFO&ndash;&gt;\r\n    <root level=\"info\">\r\n        &lt;!&ndash;<appender-ref ref=\"ASYNC\"/>&ndash;&gt;\r\n        <appender-ref ref=\"FILE\"/>\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n![下载附件](http://xiao-xiao.oss-cn-beijing.aliyuncs.com/68c47a02-6337-40df-8df1-bee18138a6f7.png?Expires=1708935548&OSSAccessKeyId=LTAI5tLUsBPzeq8nF3a4HNWx&Signature=pp1HYOhY%2FNMukLJFgWwC1EwvWtM%3D)\r\n\r\n![](http://xiao-xiao.oss-cn-beijing.aliyuncs.com/227d00df-a6a9-4cac-9b96-08d129d63f8f.jpg?Expires=1708936024&OSSAccessKeyId=LTAI5tLUsBPzeq8nF3a4HNWx&Signature=SxffEwwSiyu%2FuZzSGT%2FXFPR3Hfk%3D)', '找bug', 1677400130644, 1677400130644, 0, 0, 1, 1626451643027533825, 0, 0, 0);
INSERT INTO `question` VALUES (22, '答辩提问', '提问测试', 'git', 1685148530743, 1685148530743, 0, 0, 0, 1626609807895044099, 0, 1, 0);

-- ----------------------------
-- Table structure for sorts
-- ----------------------------
DROP TABLE IF EXISTS `sorts`;
CREATE TABLE `sorts`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '类别ID',
  `sort_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '类别名称',
  `gmt_create` bigint NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1626138145814859779 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sorts
-- ----------------------------
INSERT INTO `sorts` VALUES (1, '开发工具', 1676516376468);
INSERT INTO `sorts` VALUES (2, '开发语言', 1676516376468);
INSERT INTO `sorts` VALUES (3, '开发框架', 1676516376468);
INSERT INTO `sorts` VALUES (4, '服务器', 1676516376468);
INSERT INTO `sorts` VALUES (5, '数据库', 1676516376468);
INSERT INTO `sorts` VALUES (6, '其它', 1676516376468);

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '标签ID',
  `sort_id` bigint NOT NULL COMMENT '类别ID',
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标签名',
  `gmt_create` bigint NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1662256698322620418 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES (1625753043934908418, 1, 'intellij-idea', 1676516376468);
INSERT INTO `tags` VALUES (1625753167641710594, 1, 'git', 1676516376468);
INSERT INTO `tags` VALUES (1625753189741498369, 1, 'github', 1676516376468);
INSERT INTO `tags` VALUES (1625753219042906113, 1, 'vscode', 1676516376468);
INSERT INTO `tags` VALUES (1625753292917182465, 1, 'vim', 1676516376468);
INSERT INTO `tags` VALUES (1625753313590906882, 1, 'sublime', 1676516376468);
INSERT INTO `tags` VALUES (1625753425012592642, 1, 'eclipse', 1676516376468);
INSERT INTO `tags` VALUES (1625753471896522753, 1, 'xcode', 1676516376468);
INSERT INTO `tags` VALUES (1625753488778596353, 1, 'maven', 1676516376468);
INSERT INTO `tags` VALUES (1625753507069956098, 1, 'ide', 1676516376468);
INSERT INTO `tags` VALUES (1625753567161749505, 1, 'svn', 1676516376468);
INSERT INTO `tags` VALUES (1625753596505100289, 1, 'android-studio', 1676516376468);
INSERT INTO `tags` VALUES (1625753671864160257, 1, 'atom', 1676516376468);
INSERT INTO `tags` VALUES (1625753696027545602, 1, 'emacs', 1676516376468);
INSERT INTO `tags` VALUES (1625753715044519937, 1, 'textmate', 1676516376468);
INSERT INTO `tags` VALUES (1625753743058276353, 1, 'hg', 1676516376468);
INSERT INTO `tags` VALUES (1625753804274143234, 2, 'java', 1676516376468);
INSERT INTO `tags` VALUES (1625753829670653953, 2, 'c/c++', 1676516376468);
INSERT INTO `tags` VALUES (1625753855801167874, 2, 'python', 1676516376468);
INSERT INTO `tags` VALUES (1625753874490986497, 2, 'golang', 1676516376468);
INSERT INTO `tags` VALUES (1625753900944461826, 2, 'c#', 1676516376468);
INSERT INTO `tags` VALUES (1625753927121113090, 2, 'php', 1676516376468);
INSERT INTO `tags` VALUES (1625753947648036865, 2, 'javascript', 1676516376468);
INSERT INTO `tags` VALUES (1625753967344488449, 2, 'scala', 1676516376468);
INSERT INTO `tags` VALUES (1625753992187351042, 2, 'html', 1676516376468);
INSERT INTO `tags` VALUES (1625754013297283074, 2, 'html5', 1676516376468);
INSERT INTO `tags` VALUES (1625754034474323970, 2, 'css', 1676516376468);
INSERT INTO `tags` VALUES (1625754072462135297, 2, 'node·js', 1676516376468);
INSERT INTO `tags` VALUES (1625754117618012162, 2, 'objective-c', 1676516376468);
INSERT INTO `tags` VALUES (1625754159166787586, 2, 'typescript', 1676516376468);
INSERT INTO `tags` VALUES (1625754180813590530, 2, 'shell', 1676516376468);
INSERT INTO `tags` VALUES (1625754215433375746, 2, 'swift', 1676516376468);
INSERT INTO `tags` VALUES (1625754230394458113, 2, 'sass', 1676516376468);
INSERT INTO `tags` VALUES (1625754249331740673, 2, 'ruby', 1676516376468);
INSERT INTO `tags` VALUES (1625754277186113538, 2, 'bash', 1676516376468);
INSERT INTO `tags` VALUES (1625754300221231106, 2, 'less', 1676516376468);
INSERT INTO `tags` VALUES (1625754326326579201, 2, 'asp·net', 1676516376468);
INSERT INTO `tags` VALUES (1625754351169441793, 2, 'lua', 1676516376468);
INSERT INTO `tags` VALUES (1625754372505866241, 2, 'coffeescript', 1676516376468);
INSERT INTO `tags` VALUES (1625754390990163969, 2, 'actionscript', 1676516376468);
INSERT INTO `tags` VALUES (1625754410548203521, 2, 'rust', 1676516376468);
INSERT INTO `tags` VALUES (1625754432228560897, 2, 'erlang', 1676516376468);
INSERT INTO `tags` VALUES (1625754455922184194, 2, 'perl', 1676516376468);
INSERT INTO `tags` VALUES (1625754517049970690, 3, 'spring', 1676516376468);
INSERT INTO `tags` VALUES (1625754535840452610, 3, 'springmvc', 1676516376468);
INSERT INTO `tags` VALUES (1625754552575725570, 3, 'springboot', 1676516376468);
INSERT INTO `tags` VALUES (1625754570795782145, 3, 'springcloud', 1676516376468);
INSERT INTO `tags` VALUES (1625754589733064705, 3, 'mybatis', 1676516376468);
INSERT INTO `tags` VALUES (1625754607898595329, 3, 'bootstrap', 1676516376468);
INSERT INTO `tags` VALUES (1625754624512233473, 3, 'express', 1676516376468);
INSERT INTO `tags` VALUES (1625754648537206785, 3, 'django', 1676516376468);
INSERT INTO `tags` VALUES (1625754676320276481, 3, 'flask', 1676516376468);
INSERT INTO `tags` VALUES (1625754702664699905, 3, 'yii', 1676516376468);
INSERT INTO `tags` VALUES (1625754727662751745, 3, 'ruby-on-rails', 1676516376468);
INSERT INTO `tags` VALUES (1625754749036924930, 3, 'tornado', 1676516376468);
INSERT INTO `tags` VALUES (1625754767756103681, 3, 'koa', 1676516376468);
INSERT INTO `tags` VALUES (1625754785770639361, 3, 'struts', 1676516376468);
INSERT INTO `tags` VALUES (1625754814203826177, 3, 'laravel', 1676516376468);
INSERT INTO `tags` VALUES (1625754888463978498, 4, 'linux', 1676516376468);
INSERT INTO `tags` VALUES (1625754907682279425, 4, 'nginx', 1676516376468);
INSERT INTO `tags` VALUES (1625754931312988161, 4, 'docker', 1676516376468);
INSERT INTO `tags` VALUES (1625754948153118721, 4, 'apache', 1676516376468);
INSERT INTO `tags` VALUES (1625754967673409538, 4, 'ubuntu', 1676516376468);
INSERT INTO `tags` VALUES (1625754988481351681, 4, 'centos', 1676516376468);
INSERT INTO `tags` VALUES (1625755010933460993, 4, '缓存', 1676516376468);
INSERT INTO `tags` VALUES (1625755030797684737, 4, 'tomcat', 1676516376468);
INSERT INTO `tags` VALUES (1625755057683173378, 4, '负载均衡', 1676516376468);
INSERT INTO `tags` VALUES (1625755080139476994, 4, 'unix', 1676516376468);
INSERT INTO `tags` VALUES (1625755099622019073, 4, 'hadoop', 1676516376468);
INSERT INTO `tags` VALUES (1625755138343833602, 4, 'windows-server', 1676516376468);
INSERT INTO `tags` VALUES (1625755190294482945, 5, 'mysql', 1676516376468);
INSERT INTO `tags` VALUES (1625755208229326850, 5, 'redis', 1676516376468);
INSERT INTO `tags` VALUES (1625755225119789058, 5, 'mongodb', 1676516376468);
INSERT INTO `tags` VALUES (1625755242144468994, 5, 'sql', 1676516376468);
INSERT INTO `tags` VALUES (1625755260289028097, 5, 'oracle', 1676516376468);
INSERT INTO `tags` VALUES (1625755293474361345, 5, 'nosql', 1676516376468);
INSERT INTO `tags` VALUES (1625755316681445378, 5, 'memcached', 1676516376468);
INSERT INTO `tags` VALUES (1625755337564884994, 5, 'elasticsearch', 1676516376468);
INSERT INTO `tags` VALUES (1625755357861122050, 5, 'sqlserver', 1676516376468);
INSERT INTO `tags` VALUES (1625755383794503682, 5, 'postgresql', 1676516376468);
INSERT INTO `tags` VALUES (1625755402715009025, 5, 'sqlite', 1676516376468);
INSERT INTO `tags` VALUES (1625755451398295553, 6, '找bug', 1676516376468);
INSERT INTO `tags` VALUES (1625755467957407746, 6, '测试', 1676516376468);
INSERT INTO `tags` VALUES (1625755489482575874, 6, '冒泡', 1676516376468);
INSERT INTO `tags` VALUES (1625755511351676929, 6, '交友', 1676516376468);
INSERT INTO `tags` VALUES (1625755528820953090, 6, '生活', 1676516376468);
INSERT INTO `tags` VALUES (1625755546369921026, 6, '电影', 1676516376468);
INSERT INTO `tags` VALUES (1625755566334808066, 6, '音乐', 1676516376468);
INSERT INTO `tags` VALUES (1625755583879581697, 6, '读书', 1676516376468);
INSERT INTO `tags` VALUES (1625755602674257922, 6, '美食', 1676516376468);
INSERT INTO `tags` VALUES (1625755620730736642, 6, '游戏', 1676516376468);
INSERT INTO `tags` VALUES (1625755640003563521, 6, '科技', 1676516376468);
INSERT INTO `tags` VALUES (1625755662170460162, 6, '数码', 1676516376468);
INSERT INTO `tags` VALUES (1625755680117886977, 6, '理财', 1676516376468);
INSERT INTO `tags` VALUES (1662256698322620417, 6, '演示测试', 1685116800000);

-- ----------------------------
-- Table structure for tb_badge
-- ----------------------------
DROP TABLE IF EXISTS `tb_badge`;
CREATE TABLE `tb_badge`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '徽章ID',
  `title` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '徽章标题',
  `url` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '徽章地址',
  `badge_name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '徽章主体信息',
  `value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '徽章值',
  `color` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '徽章颜色',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_badge
-- ----------------------------
INSERT INTO `tb_badge` VALUES (2, 'coisini.cn', 'https://coisini.cn', 'coisini', 'coisini.cn', 'red', '2022-03-29 15:28:34', '2023-05-07 04:39:22');
INSERT INTO `tb_badge` VALUES (3, 'Gitee', 'https://gitee.com/xiangshaw', 'gitee', 'xiangshaw', 'blue', '2022-03-29 15:32:41', '2023-05-07 04:39:54');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `account_id` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '认证ID',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '名称',
  `token` char(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'token',
  `gmt_create` bigint NOT NULL COMMENT '创建时间',
  `gmt_modified` bigint NOT NULL COMMENT '修改时间',
  `bio` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '描述',
  `avatar_url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '头像地址',
  `password` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '加密盐',
  `phone` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` tinyint UNSIGNED NULL DEFAULT NULL COMMENT '0男1女2未知',
  `certification` tinyint UNSIGNED NULL DEFAULT 1 COMMENT '0是1否 认证',
  `status` tinyint UNSIGNED NULL DEFAULT 0 COMMENT '0正常1锁定',
  `is_deleted` tinyint NOT NULL DEFAULT 0 COMMENT '删除标记0正常 1删除',
  `login_time` bigint NULL DEFAULT NULL COMMENT '登录时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1657665658072174594 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '1@2qq.com', 'coisini', '9f63b5b8-ad49-4668-98da-86193318f20d', 1673091537294, 1673091537294, '相逢的人会再相逢', 'http://localhost:221/b9d58a22d5bb4ed0922701d98cf75433', '114fb21cbce64878c8099a7821898a19', '1dd7b1b35d2d45cca0466af1910cd2b2', '17600000000', 0, 0, 0, 0, 1684032920926);
INSERT INTO `user` VALUES (1626451643027533825, '1@2.com', '1@2.com', 'a34e617b-1d6a-4bdf-b70d-16990647ee78', 1685148450787, 1685148450787, '描述测试1', 'http://localhost:221/5b367f473a8145d7966b163fcbfa13ca', '79dca9b7e6a26496bbb20adddffd0b33', '2e938154d5044669bc675287b658497d', '16666666666', 1, 1, 0, 0, 1677399509305);
INSERT INTO `user` VALUES (1626528696624025602, '1@3.com', '1@3.com', '93bb7473-448c-4a92-87dd-36ab6d24c187', 1685148450787, 1685148450787, '测试添加', 'http://localhost:221/10f43ac617b047889040f6a8c557b4bb', '079845fe39c4e73a94a8ece416d4b570', '07e3b44ab7914a5fa4a9316c885088d1', '16666666665', 0, 1, 0, 0, NULL);
INSERT INTO `user` VALUES (1626531712840261634, '1@4.com', '1@4.com', '99718943-d943-4589-bc07-387d0e5c20b6', 1685148450787, 1685148450787, '是你眼中笑意，我有意沉沦。', 'http://localhost:221/6403b04f05d945c3a489eb84ea3787ca', 'a2020bc89ccfa698d67b2813437fc32c', '89d97e54c94d461298c8526626a5d754', '16666666664', 0, 1, 0, 0, 1693079630337);
INSERT INTO `user` VALUES (1626606838646616065, '1@5.com', '1@5.com', '31e91ff8-bd93-4988-85a2-1a5e08e92676', 1676648265875, 1676648265875, '2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222', 'http://localhost:221/f00d36e0e3604d6983a4b4e8e1b4340b', '5a0ccc78b48f4350659a3ba41c7e5b4e', '4021f2119769457da195ba6b9c039827', '16666666663', 1, 1, 0, 0, NULL);
INSERT INTO `user` VALUES (1626607474079477762, '1@6.com', '1@6.com', '5254414d-19d0-40df-8ca5-e1935c181959', 1676648408424, 1676648409166, '1', 'http://localhost:221/574dc0c2dd614235bf507a709bfb769b', '7f54cd75e8882149b5795b5ef83830b0', '8b24406b278c40aeb1c200a0ac1bed85', '16666666662', 1, 1, 0, 0, 1677395343931);
INSERT INTO `user` VALUES (1626609124953366529, '1@7.com', '1@7.com', '2cd32c5b-be32-4c43-844d-b35a04af1c4c', 1676648810968, 1676648810968, '1', 'http://localhost:221/a9655766bfac4fa18014904638d9b6f7', '899b41a9e3cc52c1a7dcc7b41683fe1d', '5b414087db1f45fcac7e1a43ab0be9c6', '16666666661', 1, 1, 0, 0, 1677396859233);
INSERT INTO `user` VALUES (1626609807895044097, '1@8.com', '1@8.com', 'c73ef1fd-5605-4bc2-b22b-5581695ccd00', 1676648973797, 1676648973797, '3', 'http://localhost:221/ba07db4513b44e12b5ffc308b660b388', '114fb21cbce64878c8099a7821898a19', '1dd7b1b35d2d45cca0466af1910cd2b2', '16666666660', 0, 1, 0, 0, 1677397125823);

SET FOREIGN_KEY_CHECKS = 1;
